# Master Product Specification: Infinite Coding Loop ("The Game")

## 1. Vision
The **Infinite Coding Loop** is an autonomous, self-evolving software development engine modeled as a **Real-Time Strategy (RTS) Game**. Users do not "run a script"; they "manage a factory" of AI workers (Units) that collaborate to solve engineering Quests.

## 2. Core Pillars
1.  **Gamification:** The interface must feel like a game. Workers are characters, tasks are quests, successful tests earn coins. This makes observability engaging.
2.  **Immutability:** The entire system is Event Sourced. "If it's not in the Event Log, it didn't happen." This ensures perfect reproducibility and time-travel debugging.
3.  **Modularity:** The system is composed of loose coupled Workers communicating via a strict Protocol. Workers can be local, remote, Native (Rust), or AI (LLM).
4.  **Self-Correction:** The cycle includes mandatory "Socratic Phases" and "Cross-Checks" to validate assumptions and code quality.
5.  **The Infinite Loop:** The engine operates on a continuous "Plan-Execute-Verify" cycle. It remembers state across sessions, allowing it to seamlessly resume complex, multi-day engineering tasks without human hand-holding.
6.  **Relational Knowledge Graph:** All entities (Missions, Tasks, Workers, Artifacts) are nodes in a persistent graph. This allows for clear visualization of dependencies ("Who is working on what?", "Which file caused this error?") and enables complex reasoning about the project structure.

## 3. System Architecture: The Core Primitives
The engine is built on three fundamental abstractions that interact in an infinite loop:

### A. Workers ("The Process")
Workers are the **logic units** that manage workflows. They are stateful, context-aware, and responsible for orchestration.
- **Responsibility**: Receive a `Task`, decide *how* to solve it, invoke `CLI Agents`, and report success/failure.
- **Examples**: 
    - `PlannerWorker`: Breaks down high-level goals.
    - `CoderWorker`: Implements code changes.
    - `VerifierWorker`: Runs tests and analyzes results.

### B. Tasks ("The Intent")
Tasks are discrete **units of work** generated by Planners or recursive Workers.
- **Structure**: Strongly typed (e.g., `Plan`, `Implement`, `Verify`, `Deploy`).
- **Flow**: Tasks are queued, assigned to Workers, and track their own status (Pending -> Running -> Success/Failure).
- **Scope**: Can range from high-level ("Build a blog") to atomic ("Fix lint error in line 42").

### C. CLI Agents ("The Brains / Tools")
Agents are the **external capabilities** that Workers utilize to perform work. They are treated as first-class primitives.
- **Nature**: Often stateless wrappers around external binaries.
- **Types**:
    - **AI Agents**: `gemini`, `claude`, `opencode` (Intelligence, Reasoning, Code Gen).
    - **Native Agents**: `git`, `cargo`, `docker`, `npm` (Deterministic execution).
- **Interface**: Workers send *Prompts* or *Commands* to Agents and parse their *Output*.

## 4. System Scope
- **Inputs:** A high-level Goal ("Build a Blog"), a Worker Profile ("Team A"), and Constraints ("Max $10 budget").
- **Outputs:** A Git Repository with formulated code, tests, and deployment scripts. The system runs indefinitely to maintain and improve this output.
- **Platform:** Native Desktop Application (Rust) with TUI.

## 5. Documentation Suite
This master document is supported by detailed technical specifications:
- **[Technical Architecture](tech_spec.md):** Rust internals, Module boundaries, API design.
- **[Data Model](data_spec.md):** Schema for Events, Profiles, and Logs.
- **[Protocol Specification](protocol_spec.md):** gRPC/Protobuf definitions for Worker communication.
- **[UX/UI Design Flow](ui_ux_spec.md):** Visual storyboards and screen sequences.
