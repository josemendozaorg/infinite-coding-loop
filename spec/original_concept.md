I need you to help me come up with TUI mockups for an application that will infinitely run a loop calling Claude Code to implement a full Application end to end by deciding on its own everything, or building a set of features, or just one feature, or just one task. And document all in the process. It finds by itself the best engineering techniques as well, the tech stack and the architecture to build the application, also make the product decisions, the testing decisions, all by itself in an infinite cycle. From a "Window", the User can see how the Infinite Loops works and how the application build progresses. Also deploying every once in a while for the User to see through the "Window" the progress. All needs to be step by step recorded in git branches and git commits, also follow engineering best practices that the look itself will also find. The infinite loop will be able to use Ollama workers, Claude Code workers, Gemini CLI workers and Github Copilot CLI workers. Let's start with the TUI wireframes images to build an idea of the product. Write the Product Specification Document as well. It must be an infinite autonomous loop. As a feature, there could be OPTIONALLY a Human in the loop to give feedback or answer questions in terms of preference, but if human does not answer, the infinite loop times out and just makes the best informed decision possible. 
The workers will not have a fixed role/function. Not necessarily Claude needs to be the complex decision maker, and Gemini the high speed context processing. They will just be simply all workers. The function will be assigned in the TUI for every worker separately, and for every  "Infinite loop" instance, the workers can have different roles/functions. In the UI, you can also determine how many workers you want to have. You can have 3 Claude Codes, and 2 Gemini CLIs, and 1 Github Copilot CLI and 4 OpenCode CLIs. So you start, define the "application idea", or "set of feature", or "feature", or "task". You also define for how long you the "infinite loop" must run. You also can OPTIONALLY define a "stopping criteria". There should be a possibility for the AI to help you define the stopping criteria for the infinite loop. The "Window" at all times must show what every Worker is doing, the artifacts it is producing, how long it's been running, the progress being made so far, and what is the plan ahead so far. There should be the possibility to PAUSE the "infinite loop" and provide feedback, and then the "infinite loop" plans will be adjusted, including the individual tasks being done by every worker at that moment.
When we say 3 Claude Code, each of them can have a different role inside the Infinity Loop instance. There must be a way to create "Worker Group Profiles". So we can define a set of Workers with predefined roles and give it a name to the Profile, like "The Full Web App Workers Group". The full transparency, observability, auditability, logging, tracing, durability (storage), resume-ability, MUST be a key part of the design of this system. We must be able to easily throubleshoot any bug, or any behaviour of every worker across time in the Infinite Loop. This all MUST become a source of self-learning for the Infinitite Loop system. It records important facts across the execution, to improve as it goes. Just not about the application that it is building, but also, there can be other "Worker Relationship Modes", where there is a real-time Relationships Orchestrator/Coordinator Worker, which depending of the functions of every worker, depending at the needs arising in real time, the Relationship Orchestrator decides to which Worker it must communicate with. Every single action, event, learning info, memory info, decision, task, outcome, must be an immutable entity persisted in a durable log. This log can be easily queried and visualized for throubleshooting and reproducibility, fault tolerance, resume-ability, accountability, Worker reward accounting. The Cycle must include A Socratic-Questioning phase during the Planning, during the Implementation, during Testing, during Deploying and during Review. All assumptions need to be research and validated, either with a Human in the loop, or if not getting answers from the Human, then the Infinite Loop must research online and use its model knowledge to make the best possible informed decision. There are native key Workers of the Infinite Loop. The Git Worker, the Research Worker, The Code Modifier Worker, the Planner Worker, the Progress manager Worker, the Memory Manager Worker, the Learning Manager Worker, the Context Manager Worker, the Context Enricher Worker, the Code Search Worker, the Ongoing Work saver Worker, the Infinite Cycle Resumer Worker, the Error Handler Worker. The way how these Workers related to each other and cooperate MUST be defined in a visual way and represented in a kind of graph as well in a text file. This MUST have profiles as well. This relationships can be defined as the Workers Relationship Profile, and can be assigned to the Worker Group Profile. So you can create a Worker Group Profile, a Worker Relationship Profile, and assign to each other to create an Infinite Loop Profile. There will be a default optimized configuration, but the User will be able to define this from scratch, or clone an existing one to modify and create a new one. There MUST be a history of the Infinite Loops executed with all the history of which Workers and the tasks completed, the tools used, everything must be recorded for the self-training of the Infinite Loop and full observability and transparency. 
This infinite lop system must be implemented in Rust, which is a fast and memory safe language. This system must be implemented in tiny increments, so that we are able to have automated tests as we go. Once it gets too big without automated testing, it can get too hard to test and bugs hard to fix. This system must also have an API interface that would allow later to implement a Web Client and a Mobile Client, and workers would run somewhere in a remote Server. This is a vision of the architecture long term. The Workers do not need to run in the same server either, they could be on remote servers, but again this is a long term vision, we need to move in small increments. There MUST be an efficient communication protocol between the Workers to make the communication light, fast and secure, no boilerplate and garbage, just a tailored for purpose protocol. There MUST be a way to have a marketplace with the Inifinite Loop Profiles and Worker Group Profiles to share with other that would like to use it as well. They must be versioned to be able to evolved them in a controlled and documented manner. Every phase MUST have a iteration and improvement phase to make it better, using Cross-Check Workers to check each others work. Specially the Planner, Coder and Tester. Other native Workers MUST be present too, the Linter Worker, the Compiler Worker, the Tests Runner Worker,  the Deployment Runner Worker, the CICD Implementer Worker. The "Window" MUST have a master view where it is displayed in real time how every Worker performs its work and cooperate with the other Workers, and showing what tools is using each Worker and what resources each Worker is consuming in real time, like a Game Scene, where every Worker is a character, and the whole "Game" Infinite Loop goal is to achieve some "Game Checkpoints" and pass some "Quests" while every Worker gather "Coins" for every work that it performs. Every "Game Infinite Loop" will never end, just as every application, it never ends. It just continues improving, operating in production and other environments. All the graph interactions between the Workers must be deterministally coded, but also, there can be other "Worker Relationship Modes", where there is a real-time Relationships Orchestrator/Coordinator Worker, which depending of the functions of every worker, depending at the needs arising in real time, the Relationship Orchestrator decides to which Worker it must communicate with. Every single action, event, learning info, memory info, decision, task, outcome, must be an immutable entity persisted in a durable log. This log can be easily queried and visualized for throubleshooting and reproducibility, fault tolerance, resume-ability, accountability, Worker reward accounting. 
We will not be coding at all. We will create a bunch of detailed Product Specification Documents with all what we have discussed so far. The product needs to be very clearly specified, including the technology stack and design. Databases, modules, APIs, application, layers, communication protocols, and all UI UX Design in a sequence of UI frames that show the User navigation frames.
Come up with a list of incremental product features to implement, in separated folders in /specs/features, where each product feature inside must have a progress.md file to keep track of implementation tasks and progress and errors and learnings, a dependencies.md file saying what product features must be first before implementing the product feature, a datamodel.md file with all database tasks to implement and entities to create and all data related implementation changes, a api.md file with all API tasks changes to implement including the specs format lenght and all relationship and attributes details, an ui.md with all the tasks to implement in the user interface, a businesslogic.md file containing all the logic of the feature wiring data changes and api changes and ui changes.
we need to start with the full data model first. 
The features must be thought in a way that can be tested little by little, incrementally.
Revise the list of features and rethink to be able to test small features at a time to be in control of the code that is being written.
The features must be user oriented.
