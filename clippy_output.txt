    Checking dass-engine v0.1.0 (/home/dev/repos/infinite-coding-loop/crates/dass-engine)
error: using `clone` on type `AgentRole` which implements the `Copy` trait
  --> crates/dass-engine/src/agents/generic.rs:43:9
   |
43 |         self.role.clone()
   |         ^^^^^^^^^^^^^^^^^ help: try removing the `clone` call: `self.role`
   |
   = help: for further information visit https://rust-lang.github.io/rust-clippy/rust-1.92.0/index.html#clone_on_copy
   = note: `-D clippy::clone-on-copy` implied by `-D warnings`
   = help: to override `-D warnings` add `#[allow(clippy::clone_on_copy)]`

error: this `impl` can be derived
 --> /home/dev/repos/infinite-coding-loop/target/debug/build/dass-engine-31d7b5bbc214e41e/out/domain_types.rs:1:77570
  |
1 | ...parse () } } impl :: std :: default :: Default for FeatureStatus { fn default () -> Self { FeatureStatus :: Proposed } } # [doc = "`Fi...
  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: for further information visit https://rust-lang.github.io/rust-clippy/rust-1.92.0/index.html#derivable_impls
  = note: `-D clippy::derivable-impls` implied by `-D warnings`
  = help: to override `-D warnings` add `#[allow(clippy::derivable_impls)]`
help: replace the manual implementation with a derive attribute and mark the default variant
  |
1 ~ # [doc = r" Error types."] pub mod error { # [doc = r" Error from a `TryFrom` or `FromStr` implementation."] pub struct ConversionError (:: std :: borrow :: Cow < 'static , str >) ; impl :: std :: error :: Error for ConversionError { } impl :: std :: fmt :: Display for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Display :: fmt (& self . 0 , f) } } impl :: std :: fmt :: Debug for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Debug :: fmt (& self . 0 , f) } } impl From < & 'static str > for ConversionError { fn from (value : & 'static str) -> Self { Self (value . into ()) } } impl From < String > for ConversionError { fn from (value : String) -> Self { Self (value . into ()) } } } # [doc = "An AI worker responsible for creating specific artifacts (The 'Who')."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/agent.schema.json\","] # [doc = "  \"title\": \"Agent\","] # [doc = "  \"description\": \"An AI worker responsible for creating specific artifacts (The 'Who').\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"responsibilities\","] # [doc = "        \"role\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Agent\""] # [doc = "        },"] # [doc = "        \"responsibilities\": {"] # [doc = "          \"description\": \"List of Entity kinds this agent produces (e.g., 'Requirement', 'Plan').\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"role\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"ProductManager\","] # [doc = "            \"Architect\","] # [doc = "            \"Engineer\","] # [doc = "            \"QA\","] # [doc = "            \"Manager\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"system_prompt\": {"] # [doc = "          \"description\": \"The personality and constraints for this agent.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"tools\": {"] # [doc = "          \"description\": \"List of allowed tools (e.g., 'search_web', 'write_file').\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Agent { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : AgentKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "List of Entity kinds this agent produces (e.g., 'Requirement', 'Plan')."] pub responsibilities : :: std :: vec :: Vec < :: std :: string :: String > , pub role : AgentRole , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "The personality and constraints for this agent."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub system_prompt : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "List of allowed tools (e.g., 'search_web', 'write_file')."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tools : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Agent > for Agent { fn from (value : & Agent) -> Self { value . clone () } } impl Agent { pub fn builder () -> builder :: Agent { Default :: default () } } # [doc = "`AgentKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Agent\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum AgentKind { Agent , } impl :: std :: convert :: From < & Self > for AgentKind { fn from (value : & AgentKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for AgentKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Agent => f . write_str ("Agent") , } } } impl :: std :: str :: FromStr for AgentKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Agent" => Ok (Self :: Agent) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for AgentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for AgentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for AgentKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`AgentRole`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"ProductManager\","] # [doc = "    \"Architect\","] # [doc = "    \"Engineer\","] # [doc = "    \"QA\","] # [doc = "    \"Manager\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum AgentRole { ProductManager , Architect , Engineer , # [serde (rename = "QA")] Qa , Manager , } impl :: std :: convert :: From < & Self > for AgentRole { fn from (value : & AgentRole) -> Self { value . clone () } } impl :: std :: fmt :: Display for AgentRole { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ProductManager => f . write_str ("ProductManager") , Self :: Architect => f . write_str ("Architect") , Self :: Engineer => f . write_str ("Engineer") , Self :: Qa => f . write_str ("QA") , Self :: Manager => f . write_str ("Manager") , } } } impl :: std :: str :: FromStr for AgentRole { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ProductManager" => Ok (Self :: ProductManager) , "Architect" => Ok (Self :: Architect) , "Engineer" => Ok (Self :: Engineer) , "QA" => Ok (Self :: Qa) , "Manager" => Ok (Self :: Manager) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for AgentRole { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for AgentRole { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for AgentRole { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ArchitectureComponent`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/architecture_component.schema.json\","] # [doc = "  \"title\": \"ArchitectureComponent\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"layer\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"ArchitectureComponent\""] # [doc = "        },"] # [doc = "        \"layer\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Frontend\","] # [doc = "            \"Backend\","] # [doc = "            \"Database\","] # [doc = "            \"Infrastructure\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct ArchitectureComponent { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : ArchitectureComponentKind , pub layer : ArchitectureComponentLayer , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & ArchitectureComponent > for ArchitectureComponent { fn from (value : & ArchitectureComponent) -> Self { value . clone () } } impl ArchitectureComponent { pub fn builder () -> builder :: ArchitectureComponent { Default :: default () } } # [doc = "`ArchitectureComponentKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ArchitectureComponent\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ArchitectureComponentKind { ArchitectureComponent , } impl :: std :: convert :: From < & Self > for ArchitectureComponentKind { fn from (value : & ArchitectureComponentKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ArchitectureComponentKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ArchitectureComponent => f . write_str ("ArchitectureComponent") , } } } impl :: std :: str :: FromStr for ArchitectureComponentKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ArchitectureComponent" => Ok (Self :: ArchitectureComponent) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ArchitectureComponentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ArchitectureComponentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ArchitectureComponentKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ArchitectureComponentLayer`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Frontend\","] # [doc = "    \"Backend\","] # [doc = "    \"Database\","] # [doc = "    \"Infrastructure\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ArchitectureComponentLayer { Frontend , Backend , Database , Infrastructure , } impl :: std :: convert :: From < & Self > for ArchitectureComponentLayer { fn from (value : & ArchitectureComponentLayer) -> Self { value . clone () } } impl :: std :: fmt :: Display for ArchitectureComponentLayer { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Frontend => f . write_str ("Frontend") , Self :: Backend => f . write_str ("Backend") , Self :: Database => f . write_str ("Database") , Self :: Infrastructure => f . write_str ("Infrastructure") , } } } impl :: std :: str :: FromStr for ArchitectureComponentLayer { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Frontend" => Ok (Self :: Frontend) , "Backend" => Ok (Self :: Backend) , "Database" => Ok (Self :: Database) , "Infrastructure" => Ok (Self :: Infrastructure) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ArchitectureComponentLayer { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ArchitectureComponentLayer { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ArchitectureComponentLayer { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A fundamental structural organization schema (e.g., MVC, Microservices)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/architecture_pattern.schema.json\","] # [doc = "  \"title\": \"ArchitecturePattern\","] # [doc = "  \"description\": \"A fundamental structural organization schema (e.g., MVC, Microservices).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"type\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"ArchitecturePattern\""] # [doc = "        },"] # [doc = "        \"principles\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"structure_diagram\": {"] # [doc = "          \"description\": \"Mermaid or text diagram of the pattern structure.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Monolith\","] # [doc = "            \"Microservices\","] # [doc = "            \"Event-Driven\","] # [doc = "            \"Layered\","] # [doc = "            \"Hexagonal\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct ArchitecturePattern { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : ArchitecturePatternKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub principles : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Mermaid or text diagram of the pattern structure."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub structure_diagram : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (rename = "type")] pub type_ : ArchitecturePatternType , } impl :: std :: convert :: From < & ArchitecturePattern > for ArchitecturePattern { fn from (value : & ArchitecturePattern) -> Self { value . clone () } } impl ArchitecturePattern { pub fn builder () -> builder :: ArchitecturePattern { Default :: default () } } # [doc = "`ArchitecturePatternKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ArchitecturePattern\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ArchitecturePatternKind { ArchitecturePattern , } impl :: std :: convert :: From < & Self > for ArchitecturePatternKind { fn from (value : & ArchitecturePatternKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ArchitecturePatternKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ArchitecturePattern => f . write_str ("ArchitecturePattern") , } } } impl :: std :: str :: FromStr for ArchitecturePatternKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ArchitecturePattern" => Ok (Self :: ArchitecturePattern) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ArchitecturePatternKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ArchitecturePatternKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ArchitecturePatternKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ArchitecturePatternType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Monolith\","] # [doc = "    \"Microservices\","] # [doc = "    \"Event-Driven\","] # [doc = "    \"Layered\","] # [doc = "    \"Hexagonal\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ArchitecturePatternType { Monolith , Microservices , # [serde (rename = "Event-Driven")] EventDriven , Layered , Hexagonal , } impl :: std :: convert :: From < & Self > for ArchitecturePatternType { fn from (value : & ArchitecturePatternType) -> Self { value . clone () } } impl :: std :: fmt :: Display for ArchitecturePatternType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Monolith => f . write_str ("Monolith") , Self :: Microservices => f . write_str ("Microservices") , Self :: EventDriven => f . write_str ("Event-Driven") , Self :: Layered => f . write_str ("Layered") , Self :: Hexagonal => f . write_str ("Hexagonal") , } } } impl :: std :: str :: FromStr for ArchitecturePatternType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Monolith" => Ok (Self :: Monolith) , "Microservices" => Ok (Self :: Microservices) , "Event-Driven" => Ok (Self :: EventDriven) , "Layered" => Ok (Self :: Layered) , "Hexagonal" => Ok (Self :: Hexagonal) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ArchitecturePatternType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ArchitecturePatternType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ArchitecturePatternType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A formal proposal to modify any artifact (SWEBOK: Configuration Control)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/change_request.schema.json\","] # [doc = "  \"title\": \"ChangeRequest\","] # [doc = "  \"description\": \"A formal proposal to modify any artifact (SWEBOK: Configuration Control).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"status\","] # [doc = "        \"target_entity_id\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"ChangeRequest\""] # [doc = "        },"] # [doc = "        \"reason\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"status\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Proposed\","] # [doc = "            \"Approved\","] # [doc = "            \"Rejected\","] # [doc = "            \"Implemented\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"target_entity_id\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"uuid\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct ChangeRequest { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : ChangeRequestKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub reason : :: std :: option :: Option < :: std :: string :: String > , pub status : ChangeRequestStatus , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , pub target_entity_id : :: uuid :: Uuid , } impl :: std :: convert :: From < & ChangeRequest > for ChangeRequest { fn from (value : & ChangeRequest) -> Self { value . clone () } } impl ChangeRequest { pub fn builder () -> builder :: ChangeRequest { Default :: default () } } # [doc = "`ChangeRequestKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ChangeRequest\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ChangeRequestKind { ChangeRequest , } impl :: std :: convert :: From < & Self > for ChangeRequestKind { fn from (value : & ChangeRequestKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ChangeRequestKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ChangeRequest => f . write_str ("ChangeRequest") , } } } impl :: std :: str :: FromStr for ChangeRequestKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ChangeRequest" => Ok (Self :: ChangeRequest) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ChangeRequestKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ChangeRequestKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ChangeRequestKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ChangeRequestStatus`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Proposed\","] # [doc = "    \"Approved\","] # [doc = "    \"Rejected\","] # [doc = "    \"Implemented\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ChangeRequestStatus { Proposed , Approved , Rejected , Implemented , } impl :: std :: convert :: From < & Self > for ChangeRequestStatus { fn from (value : & ChangeRequestStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for ChangeRequestStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Proposed => f . write_str ("Proposed") , Self :: Approved => f . write_str ("Approved") , Self :: Rejected => f . write_str ("Rejected") , Self :: Implemented => f . write_str ("Implemented") , } } } impl :: std :: str :: FromStr for ChangeRequestStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Proposed" => Ok (Self :: Proposed) , "Approved" => Ok (Self :: Approved) , "Rejected" => Ok (Self :: Rejected) , "Implemented" => Ok (Self :: Implemented) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ChangeRequestStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ChangeRequestStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ChangeRequestStatus { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`Command`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/command.schema.json\","] # [doc = "  \"title\": \"Command\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"executable\","] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"arguments\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"executable\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Command\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Command { # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub arguments : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub executable : :: std :: string :: String , pub id : :: uuid :: Uuid , pub kind : CommandKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Command > for Command { fn from (value : & Command) -> Self { value . clone () } } impl Command { pub fn builder () -> builder :: Command { Default :: default () } } # [doc = "`CommandKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Command\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum CommandKind { Command , } impl :: std :: convert :: From < & Self > for CommandKind { fn from (value : & CommandKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for CommandKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Command => f . write_str ("Command") , } } } impl :: std :: str :: FromStr for CommandKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Command" => Ok (Self :: Command) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for CommandKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for CommandKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for CommandKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`DataModel`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/data_model.schema.json\","] # [doc = "  \"title\": \"DataModel\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"schema_definition\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"DataModel\""] # [doc = "        },"] # [doc = "        \"schema_definition\": {"] # [doc = "          \"description\": \"SQL or JSON schema content\","] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DataModel { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : DataModelKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "SQL or JSON schema content"] pub schema_definition : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & DataModel > for DataModel { fn from (value : & DataModel) -> Self { value . clone () } } impl DataModel { pub fn builder () -> builder :: DataModel { Default :: default () } } # [doc = "`DataModelKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"DataModel\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum DataModelKind { DataModel , } impl :: std :: convert :: From < & Self > for DataModelKind { fn from (value : & DataModelKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for DataModelKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: DataModel => f . write_str ("DataModel") , } } } impl :: std :: str :: FromStr for DataModelKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "DataModel" => Ok (Self :: DataModel) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for DataModelKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for DataModelKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for DataModelKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Technical design description (SDD) for a feature (SWEBOK: Software Design)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/design_spec.schema.json\","] # [doc = "  \"title\": \"DesignSpec\","] # [doc = "  \"description\": \"Technical design description (SDD) for a feature (SWEBOK: Software Design).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"data_spec\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"DesignSpec\""] # [doc = "        },"] # [doc = "        \"logic_spec\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"ui_spec\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"verification_plan\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DesignSpec { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub data_spec : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : DesignSpecKind , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub logic_spec : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub ui_spec : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub verification_plan : :: std :: option :: Option < :: std :: string :: String > , } impl :: std :: convert :: From < & DesignSpec > for DesignSpec { fn from (value : & DesignSpec) -> Self { value . clone () } } impl DesignSpec { pub fn builder () -> builder :: DesignSpec { Default :: default () } } # [doc = "`DesignSpecKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"DesignSpec\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum DesignSpecKind { DesignSpec , } impl :: std :: convert :: From < & Self > for DesignSpecKind { fn from (value : & DesignSpecKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for DesignSpecKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: DesignSpec => f . write_str ("DesignSpec") , } } } impl :: std :: str :: FromStr for DesignSpecKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "DesignSpec" => Ok (Self :: DesignSpec) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for DesignSpecKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for DesignSpecKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for DesignSpecKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A data object in the domain model (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/domain_entity.schema.json\","] # [doc = "  \"title\": \"DomainEntity\","] # [doc = "  \"description\": \"A data object in the domain model (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"attributes\","] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"attributes\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"name\","] # [doc = "              \"type\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"description\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"is_primary_key\": {"] # [doc = "                \"type\": \"boolean\""] # [doc = "              },"] # [doc = "              \"name\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"required\": {"] # [doc = "                \"type\": \"boolean\""] # [doc = "              },"] # [doc = "              \"type\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"DomainEntity\""] # [doc = "        },"] # [doc = "        \"relationships\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"relation_type\","] # [doc = "              \"target_entity\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"description\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"relation_type\": {"] # [doc = "                \"enum\": ["] # [doc = "                  \"OneToOne\","] # [doc = "                  \"OneToMany\","] # [doc = "                  \"ManyToOne\","] # [doc = "                  \"ManyToMany\""] # [doc = "                ]"] # [doc = "              },"] # [doc = "              \"target_entity\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DomainEntity { pub attributes : :: std :: vec :: Vec < DomainEntityAttributesItem > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : DomainEntityKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub relationships : :: std :: vec :: Vec < DomainEntityRelationshipsItem > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & DomainEntity > for DomainEntity { fn from (value : & DomainEntity) -> Self { value . clone () } } impl DomainEntity { pub fn builder () -> builder :: DomainEntity { Default :: default () } } # [doc = "`DomainEntityAttributesItem`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"name\","] # [doc = "    \"type\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"description\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"is_primary_key\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"required\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"type\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DomainEntityAttributesItem { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub is_primary_key : :: std :: option :: Option < bool > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub required : :: std :: option :: Option < bool > , # [serde (rename = "type")] pub type_ : :: std :: string :: String , } impl :: std :: convert :: From < & DomainEntityAttributesItem > for DomainEntityAttributesItem { fn from (value : & DomainEntityAttributesItem) -> Self { value . clone () } } impl DomainEntityAttributesItem { pub fn builder () -> builder :: DomainEntityAttributesItem { Default :: default () } } # [doc = "`DomainEntityKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"DomainEntity\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum DomainEntityKind { DomainEntity , } impl :: std :: convert :: From < & Self > for DomainEntityKind { fn from (value : & DomainEntityKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for DomainEntityKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: DomainEntity => f . write_str ("DomainEntity") , } } } impl :: std :: str :: FromStr for DomainEntityKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "DomainEntity" => Ok (Self :: DomainEntity) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for DomainEntityKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for DomainEntityKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for DomainEntityKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`DomainEntityRelationshipsItem`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"relation_type\","] # [doc = "    \"target_entity\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"description\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"relation_type\": {"] # [doc = "      \"enum\": ["] # [doc = "        \"OneToOne\","] # [doc = "        \"OneToMany\","] # [doc = "        \"ManyToOne\","] # [doc = "        \"ManyToMany\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"target_entity\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DomainEntityRelationshipsItem { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub relation_type : DomainEntityRelationshipsItemRelationType , pub target_entity : :: std :: string :: String , } impl :: std :: convert :: From < & DomainEntityRelationshipsItem > for DomainEntityRelationshipsItem { fn from (value : & DomainEntityRelationshipsItem) -> Self { value . clone () } } impl DomainEntityRelationshipsItem { pub fn builder () -> builder :: DomainEntityRelationshipsItem { Default :: default () } } # [doc = "`DomainEntityRelationshipsItemRelationType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"OneToOne\","] # [doc = "    \"OneToMany\","] # [doc = "    \"ManyToOne\","] # [doc = "    \"ManyToMany\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum DomainEntityRelationshipsItemRelationType { OneToOne , OneToMany , ManyToOne , ManyToMany , } impl :: std :: convert :: From < & Self > for DomainEntityRelationshipsItemRelationType { fn from (value : & DomainEntityRelationshipsItemRelationType) -> Self { value . clone () } } impl :: std :: fmt :: Display for DomainEntityRelationshipsItemRelationType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: OneToOne => f . write_str ("OneToOne") , Self :: OneToMany => f . write_str ("OneToMany") , Self :: ManyToOne => f . write_str ("ManyToOne") , Self :: ManyToMany => f . write_str ("ManyToMany") , } } } impl :: std :: str :: FromStr for DomainEntityRelationshipsItemRelationType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "OneToOne" => Ok (Self :: OneToOne) , "OneToMany" => Ok (Self :: OneToMany) , "ManyToOne" => Ok (Self :: ManyToOne) , "ManyToMany" => Ok (Self :: ManyToMany) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for DomainEntityRelationshipsItemRelationType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for DomainEntityRelationshipsItemRelationType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for DomainEntityRelationshipsItemRelationType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`EntityMetadata`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"kind\","] # [doc = "    \"name\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"description\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"kind\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"metadata\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"additionalProperties\": true"] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"synonyms\": {"] # [doc = "      \"description\": \"Alternative names for this entity (e.g., Feature -> Epic).\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"tags\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct EntityMetadata { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : :: std :: string :: String , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & EntityMetadata > for EntityMetadata { fn from (value : & EntityMetadata) -> Self { value . clone () } } impl EntityMetadata { pub fn builder () -> builder :: EntityMetadata { Default :: default () } } # [doc = "The operational context (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/environment.schema.json\","] # [doc = "  \"title\": \"Environment\","] # [doc = "  \"description\": \"The operational context (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"type\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"container_image\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"env_variables\": {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"additionalProperties\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Environment\""] # [doc = "        },"] # [doc = "        \"os\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"secrets\": {"] # [doc = "          \"description\": \"List of secret names required (values not stored here).\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"tools\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Development\","] # [doc = "            \"Tests\","] # [doc = "            \"Staging\","] # [doc = "            \"Production\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Environment { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub container_image : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = ":: std :: collections :: HashMap::is_empty")] pub env_variables : :: std :: collections :: HashMap < :: std :: string :: String , :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : EnvironmentKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub os : :: std :: option :: Option < :: std :: string :: String > , # [doc = "List of secret names required (values not stored here)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub secrets : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tools : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (rename = "type")] pub type_ : EnvironmentType , } impl :: std :: convert :: From < & Environment > for Environment { fn from (value : & Environment) -> Self { value . clone () } } impl Environment { pub fn builder () -> builder :: Environment { Default :: default () } } # [doc = "`EnvironmentKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Environment\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum EnvironmentKind { Environment , } impl :: std :: convert :: From < & Self > for EnvironmentKind { fn from (value : & EnvironmentKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for EnvironmentKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Environment => f . write_str ("Environment") , } } } impl :: std :: str :: FromStr for EnvironmentKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Environment" => Ok (Self :: Environment) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for EnvironmentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for EnvironmentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for EnvironmentKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`EnvironmentType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Development\","] # [doc = "    \"Tests\","] # [doc = "    \"Staging\","] # [doc = "    \"Production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum EnvironmentType { Development , Tests , Staging , Production , } impl :: std :: convert :: From < & Self > for EnvironmentType { fn from (value : & EnvironmentType) -> Self { value . clone () } } impl :: std :: fmt :: Display for EnvironmentType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Development => f . write_str ("Development") , Self :: Tests => f . write_str ("Tests") , Self :: Staging => f . write_str ("Staging") , Self :: Production => f . write_str ("Production") , } } } impl :: std :: str :: FromStr for EnvironmentType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Development" => Ok (Self :: Development) , "Tests" => Ok (Self :: Tests) , "Staging" => Ok (Self :: Staging) , "Production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for EnvironmentType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for EnvironmentType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for EnvironmentType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A high-level functional capability or 'Epic'."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/feature.schema.json\","] # [doc = "  \"title\": \"Feature\","] # [doc = "  \"description\": \"A high-level functional capability or 'Epic'.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"business_value\","] # [doc = "        \"kind\","] # [doc = "        \"priority\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"business_value\": {"] # [doc = "          \"description\": \"Why this feature provides value to the business/user.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Feature\""] # [doc = "        },"] # [doc = "        \"priority\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Critical\","] # [doc = "            \"High\","] # [doc = "            \"Medium\","] # [doc = "            \"Low\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"status\": {"] # [doc = "          \"default\": \"Proposed\","] # [doc = "          \"enum\": ["] # [doc = "            \"Proposed\","] # [doc = "            \"In Progress\","] # [doc = "            \"Completed\","] # [doc = "            \"Deferred\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Feature { # [doc = "Why this feature provides value to the business/user."] pub business_value : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : FeatureKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , pub priority : FeaturePriority , # [serde (default = "defaults::feature_status")] pub status : FeatureStatus , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Feature > for Feature { fn from (value : & Feature) -> Self { value . clone () } } impl Feature { pub fn builder () -> builder :: Feature { Default :: default () } } # [doc = "`FeatureKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Feature\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum FeatureKind { Feature , } impl :: std :: convert :: From < & Self > for FeatureKind { fn from (value : & FeatureKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for FeatureKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Feature => f . write_str ("Feature") , } } } impl :: std :: str :: FromStr for FeatureKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Feature" => Ok (Self :: Feature) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for FeatureKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for FeatureKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for FeatureKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`FeaturePriority`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Critical\","] # [doc = "    \"High\","] # [doc = "    \"Medium\","] # [doc = "    \"Low\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum FeaturePriority { Critical , High , Medium , Low , } impl :: std :: convert :: From < & Self > for FeaturePriority { fn from (value : & FeaturePriority) -> Self { value . clone () } } impl :: std :: fmt :: Display for FeaturePriority { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Critical => f . write_str ("Critical") , Self :: High => f . write_str ("High") , Self :: Medium => f . write_str ("Medium") , Self :: Low => f . write_str ("Low") , } } } impl :: std :: str :: FromStr for FeaturePriority { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Critical" => Ok (Self :: Critical) , "High" => Ok (Self :: High) , "Medium" => Ok (Self :: Medium) , "Low" => Ok (Self :: Low) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for FeaturePriority { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for FeaturePriority { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for FeaturePriority { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`FeatureStatus`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"Proposed\","] # [doc = "  \"enum\": ["] # [doc = "    \"Proposed\","] # [doc = "    \"In Progress\","] # [doc = "    \"Completed\","] # [doc = "    \"Deferred\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] #[derive(Default)]
2 ~ pub enum FeatureStatus { #[default]
3 ~ Proposed , # [serde (rename = "In Progress")] InProgress , Completed , Deferred , } impl :: std :: convert :: From < & Self > for FeatureStatus { fn from (value : & FeatureStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for FeatureStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Proposed => f . write_str ("Proposed") , Self :: InProgress => f . write_str ("In Progress") , Self :: Completed => f . write_str ("Completed") , Self :: Deferred => f . write_str ("Deferred") , } } } impl :: std :: str :: FromStr for FeatureStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Proposed" => Ok (Self :: Proposed) , "In Progress" => Ok (Self :: InProgress) , "Completed" => Ok (Self :: Completed) , "Deferred" => Ok (Self :: Deferred) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for FeatureStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for FeatureStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for FeatureStatus { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } }  # [doc = "`FileSystemNode`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"name\","] # [doc = "    \"type\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"children\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"$ref\": \"#/definitions/FileSystemNode\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"description\": {"] # [doc = "      \"description\": \"Purpose of this node\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"description\": \"Name of directory or file node\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"type\": {"] # [doc = "      \"enum\": ["] # [doc = "        \"Directory\","] # [doc = "        \"File\","] # [doc = "        \"Module\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct FileSystemNode { # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub children : :: std :: vec :: Vec < FileSystemNode > , # [doc = "Purpose of this node"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Name of directory or file node"] pub name : :: std :: string :: String , # [serde (rename = "type")] pub type_ : FileSystemNodeType , } impl :: std :: convert :: From < & FileSystemNode > for FileSystemNode { fn from (value : & FileSystemNode) -> Self { value . clone () } } impl FileSystemNode { pub fn builder () -> builder :: FileSystemNode { Default :: default () } } # [doc = "`FileSystemNodeType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Directory\","] # [doc = "    \"File\","] # [doc = "    \"Module\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum FileSystemNodeType { Directory , File , Module , } impl :: std :: convert :: From < & Self > for FileSystemNodeType { fn from (value : & FileSystemNodeType) -> Self { value . clone () } } impl :: std :: fmt :: Display for FileSystemNodeType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Directory => f . write_str ("Directory") , Self :: File => f . write_str ("File") , Self :: Module => f . write_str ("Module") , } } } impl :: std :: str :: FromStr for FileSystemNodeType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Directory" => Ok (Self :: Directory) , "File" => Ok (Self :: File) , "Module" => Ok (Self :: Module) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for FileSystemNodeType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for FileSystemNodeType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for FileSystemNodeType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "An insight or error captured during execution (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/observation.schema.json\","] # [doc = "  \"title\": \"Observation\","] # [doc = "  \"description\": \"An insight or error captured during execution (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"insight\","] # [doc = "        \"kind\","] # [doc = "        \"severity\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"artifact_id\": {"] # [doc = "          \"description\": \"ID of the artifact related to this observation (Risk, TestResult, etc.)\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"context\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"insight\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Observation\""] # [doc = "        },"] # [doc = "        \"observed_at\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"date-time\""] # [doc = "        },"] # [doc = "        \"recommendation\": {"] # [doc = "          \"description\": \"Suggested action to address the observation.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"severity\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Info\","] # [doc = "            \"Warning\","] # [doc = "            \"Error\","] # [doc = "            \"Critical\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Observation { # [doc = "ID of the artifact related to this observation (Risk, TestResult, etc.)"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub artifact_id : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub context : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub insight : :: std :: string :: String , pub kind : ObservationKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub observed_at : :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , # [doc = "Suggested action to address the observation."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub recommendation : :: std :: option :: Option < :: std :: string :: String > , pub severity : ObservationSeverity , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Observation > for Observation { fn from (value : & Observation) -> Self { value . clone () } } impl Observation { pub fn builder () -> builder :: Observation { Default :: default () } } # [doc = "`ObservationKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Observation\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ObservationKind { Observation , } impl :: std :: convert :: From < & Self > for ObservationKind { fn from (value : & ObservationKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ObservationKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Observation => f . write_str ("Observation") , } } } impl :: std :: str :: FromStr for ObservationKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Observation" => Ok (Self :: Observation) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ObservationKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ObservationKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ObservationKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ObservationSeverity`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Info\","] # [doc = "    \"Warning\","] # [doc = "    \"Error\","] # [doc = "    \"Critical\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ObservationSeverity { Info , Warning , Error , Critical , } impl :: std :: convert :: From < & Self > for ObservationSeverity { fn from (value : & ObservationSeverity) -> Self { value . clone () } } impl :: std :: fmt :: Display for ObservationSeverity { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Info => f . write_str ("Info") , Self :: Warning => f . write_str ("Warning") , Self :: Error => f . write_str ("Error") , Self :: Critical => f . write_str ("Critical") , } } } impl :: std :: str :: FromStr for ObservationSeverity { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Info" => Ok (Self :: Info) , "Warning" => Ok (Self :: Warning) , "Error" => Ok (Self :: Error) , "Critical" => Ok (Self :: Critical) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ObservationSeverity { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ObservationSeverity { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ObservationSeverity { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A representation of a user role or stakeholder (e.g., 'Admin', 'Guest')."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/persona.schema.json\","] # [doc = "  \"title\": \"Persona\","] # [doc = "  \"description\": \"A representation of a user role or stakeholder (e.g., 'Admin', 'Guest').\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"role\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Persona\""] # [doc = "        },"] # [doc = "        \"responsibilities\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"role\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Persona { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : PersonaKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub responsibilities : :: std :: vec :: Vec < :: std :: string :: String > , pub role : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Persona > for Persona { fn from (value : & Persona) -> Self { value . clone () } } impl Persona { pub fn builder () -> builder :: Persona { Default :: default () } } # [doc = "`PersonaKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Persona\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PersonaKind { Persona , } impl :: std :: convert :: From < & Self > for PersonaKind { fn from (value : & PersonaKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for PersonaKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Persona => f . write_str ("Persona") , } } } impl :: std :: str :: FromStr for PersonaKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Persona" => Ok (Self :: Persona) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for PersonaKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for PersonaKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for PersonaKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A set of structured tasks to implement a specification."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/plan.schema.json\","] # [doc = "  \"title\": \"Plan\","] # [doc = "  \"description\": \"A set of structured tasks to implement a specification.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"tasks\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Plan\""] # [doc = "        },"] # [doc = "        \"tasks\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"description\","] # [doc = "              \"id\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"dependencies\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\""] # [doc = "                }"] # [doc = "              },"] # [doc = "              \"description\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"estimated_duration\": {"] # [doc = "                \"description\": \"e.g., '2h', '1d'\","] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"id\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Plan { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : PlanKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , pub tasks : :: std :: vec :: Vec < PlanTasksItem > , } impl :: std :: convert :: From < & Plan > for Plan { fn from (value : & Plan) -> Self { value . clone () } } impl Plan { pub fn builder () -> builder :: Plan { Default :: default () } } # [doc = "`PlanKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Plan\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PlanKind { Plan , } impl :: std :: convert :: From < & Self > for PlanKind { fn from (value : & PlanKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for PlanKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Plan => f . write_str ("Plan") , } } } impl :: std :: str :: FromStr for PlanKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Plan" => Ok (Self :: Plan) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for PlanKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for PlanKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for PlanKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`PlanTasksItem`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"description\","] # [doc = "    \"id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"dependencies\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"description\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"estimated_duration\": {"] # [doc = "      \"description\": \"e.g., '2h', '1d'\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PlanTasksItem { # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub dependencies : :: std :: vec :: Vec < :: std :: string :: String > , pub description : :: std :: string :: String , # [doc = "e.g., '2h', '1d'"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub estimated_duration : :: std :: option :: Option < :: std :: string :: String > , pub id : :: std :: string :: String , } impl :: std :: convert :: From < & PlanTasksItem > for PlanTasksItem { fn from (value : & PlanTasksItem) -> Self { value . clone () } } impl PlanTasksItem { pub fn builder () -> builder :: PlanTasksItem { Default :: default () } } # [doc = "The physical directory layout and logical module organization (SWEBOK: Software Construction)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/project_structure.schema.json\","] # [doc = "  \"title\": \"ProjectStructure\","] # [doc = "  \"description\": \"The physical directory layout and logical module organization (SWEBOK: Software Construction).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"layout\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"conventions\": {"] # [doc = "          \"description\": \"Language-specific rules (e.g., 'Rust: src/main.rs is entry')\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"ProjectStructure\""] # [doc = "        },"] # [doc = "        \"layout\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"$ref\": \"#/definitions/FileSystemNode\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"root_path\": {"] # [doc = "          \"description\": \"Absolute or relative root (e.g., './crate-name')\","] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct ProjectStructure { # [doc = "Language-specific rules (e.g., 'Rust: src/main.rs is entry')"] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub conventions : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : ProjectStructureKind , pub layout : :: std :: vec :: Vec < FileSystemNode > , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Absolute or relative root (e.g., './crate-name')"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub root_path : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & ProjectStructure > for ProjectStructure { fn from (value : & ProjectStructure) -> Self { value . clone () } } impl ProjectStructure { pub fn builder () -> builder :: ProjectStructure { Default :: default () } } # [doc = "`ProjectStructureKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ProjectStructure\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ProjectStructureKind { ProjectStructure , } impl :: std :: convert :: From < & Self > for ProjectStructureKind { fn from (value : & ProjectStructureKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ProjectStructureKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ProjectStructure => f . write_str ("ProjectStructure") , } } } impl :: std :: str :: FromStr for ProjectStructureKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ProjectStructure" => Ok (Self :: ProjectStructure) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ProjectStructureKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ProjectStructureKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ProjectStructureKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "An atomic unit of functionality or constraint (SWEBOK: Software Requirements)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/requirement.schema.json\","] # [doc = "  \"title\": \"Requirement\","] # [doc = "  \"description\": \"An atomic unit of functionality or constraint (SWEBOK: Software Requirements).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"acceptance_criteria\","] # [doc = "        \"kind\","] # [doc = "        \"req_type\","] # [doc = "        \"user_story\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"acceptance_criteria\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"minItems\": 1"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Requirement\""] # [doc = "        },"] # [doc = "        \"priority\": {"] # [doc = "          \"description\": \"MoSCoW prioritization.\","] # [doc = "          \"enum\": ["] # [doc = "            \"Must Have\","] # [doc = "            \"Should Have\","] # [doc = "            \"Could Have\","] # [doc = "            \"Won't Have\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"req_type\": {"] # [doc = "          \"description\": \"Classifies the requirement type (FR vs NFR).\","] # [doc = "          \"enum\": ["] # [doc = "            \"Functional\","] # [doc = "            \"Non-Functional\","] # [doc = "            \"Constraint\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"user_story\": {"] # [doc = "          \"description\": \"As a <role>, I want <feature>, so that <benefit>.\","] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Requirement { pub acceptance_criteria : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : RequirementKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "MoSCoW prioritization."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub priority : :: std :: option :: Option < RequirementPriority > , # [doc = "Classifies the requirement type (FR vs NFR)."] pub req_type : RequirementReqType , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "As a <role>, I want <feature>, so that <benefit>."] pub user_story : :: std :: string :: String , } impl :: std :: convert :: From < & Requirement > for Requirement { fn from (value : & Requirement) -> Self { value . clone () } } impl Requirement { pub fn builder () -> builder :: Requirement { Default :: default () } } # [doc = "`RequirementKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Requirement\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RequirementKind { Requirement , } impl :: std :: convert :: From < & Self > for RequirementKind { fn from (value : & RequirementKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for RequirementKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Requirement => f . write_str ("Requirement") , } } } impl :: std :: str :: FromStr for RequirementKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Requirement" => Ok (Self :: Requirement) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RequirementKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RequirementKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RequirementKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "MoSCoW prioritization."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"MoSCoW prioritization.\","] # [doc = "  \"enum\": ["] # [doc = "    \"Must Have\","] # [doc = "    \"Should Have\","] # [doc = "    \"Could Have\","] # [doc = "    \"Won't Have\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RequirementPriority { # [serde (rename = "Must Have")] MustHave , # [serde (rename = "Should Have")] ShouldHave , # [serde (rename = "Could Have")] CouldHave , # [serde (rename = "Won't Have")] WontHave , } impl :: std :: convert :: From < & Self > for RequirementPriority { fn from (value : & RequirementPriority) -> Self { value . clone () } } impl :: std :: fmt :: Display for RequirementPriority { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: MustHave => f . write_str ("Must Have") , Self :: ShouldHave => f . write_str ("Should Have") , Self :: CouldHave => f . write_str ("Could Have") , Self :: WontHave => f . write_str ("Won't Have") , } } } impl :: std :: str :: FromStr for RequirementPriority { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Must Have" => Ok (Self :: MustHave) , "Should Have" => Ok (Self :: ShouldHave) , "Could Have" => Ok (Self :: CouldHave) , "Won't Have" => Ok (Self :: WontHave) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RequirementPriority { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RequirementPriority { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RequirementPriority { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Classifies the requirement type (FR vs NFR)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Classifies the requirement type (FR vs NFR).\","] # [doc = "  \"enum\": ["] # [doc = "    \"Functional\","] # [doc = "    \"Non-Functional\","] # [doc = "    \"Constraint\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RequirementReqType { Functional , # [serde (rename = "Non-Functional")] NonFunctional , Constraint , } impl :: std :: convert :: From < & Self > for RequirementReqType { fn from (value : & RequirementReqType) -> Self { value . clone () } } impl :: std :: fmt :: Display for RequirementReqType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Functional => f . write_str ("Functional") , Self :: NonFunctional => f . write_str ("Non-Functional") , Self :: Constraint => f . write_str ("Constraint") , } } } impl :: std :: str :: FromStr for RequirementReqType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Functional" => Ok (Self :: Functional) , "Non-Functional" => Ok (Self :: NonFunctional) , "Constraint" => Ok (Self :: Constraint) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RequirementReqType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RequirementReqType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RequirementReqType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A potential future event that may negatively impact the project (SWEBOK: Risk Management)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/risk.schema.json\","] # [doc = "  \"title\": \"Risk\","] # [doc = "  \"description\": \"A potential future event that may negatively impact the project (SWEBOK: Risk Management).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"impact\","] # [doc = "        \"kind\","] # [doc = "        \"mitigation_plan\","] # [doc = "        \"probability\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"impact\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Critical\","] # [doc = "            \"Major\","] # [doc = "            \"Minor\","] # [doc = "            \"Negligible\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Risk\""] # [doc = "        },"] # [doc = "        \"mitigation_plan\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"probability\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"High\","] # [doc = "            \"Medium\","] # [doc = "            \"Low\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Risk { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub impact : RiskImpact , pub kind : RiskKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub mitigation_plan : :: std :: string :: String , pub name : :: std :: string :: String , pub probability : RiskProbability , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Risk > for Risk { fn from (value : & Risk) -> Self { value . clone () } } impl Risk { pub fn builder () -> builder :: Risk { Default :: default () } } # [doc = "`RiskImpact`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Critical\","] # [doc = "    \"Major\","] # [doc = "    \"Minor\","] # [doc = "    \"Negligible\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RiskImpact { Critical , Major , Minor , Negligible , } impl :: std :: convert :: From < & Self > for RiskImpact { fn from (value : & RiskImpact) -> Self { value . clone () } } impl :: std :: fmt :: Display for RiskImpact { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Critical => f . write_str ("Critical") , Self :: Major => f . write_str ("Major") , Self :: Minor => f . write_str ("Minor") , Self :: Negligible => f . write_str ("Negligible") , } } } impl :: std :: str :: FromStr for RiskImpact { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Critical" => Ok (Self :: Critical) , "Major" => Ok (Self :: Major) , "Minor" => Ok (Self :: Minor) , "Negligible" => Ok (Self :: Negligible) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RiskImpact { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RiskImpact { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RiskImpact { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`RiskKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Risk\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RiskKind { Risk , } impl :: std :: convert :: From < & Self > for RiskKind { fn from (value : & RiskKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for RiskKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Risk => f . write_str ("Risk") , } } } impl :: std :: str :: FromStr for RiskKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Risk" => Ok (Self :: Risk) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RiskKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RiskKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RiskKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`RiskProbability`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"High\","] # [doc = "    \"Medium\","] # [doc = "    \"Low\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RiskProbability { High , Medium , Low , } impl :: std :: convert :: From < & Self > for RiskProbability { fn from (value : & RiskProbability) -> Self { value . clone () } } impl :: std :: fmt :: Display for RiskProbability { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: High => f . write_str ("High") , Self :: Medium => f . write_str ("Medium") , Self :: Low => f . write_str ("Low") , } } } impl :: std :: str :: FromStr for RiskProbability { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "High" => Ok (Self :: High) , "Medium" => Ok (Self :: Medium) , "Low" => Ok (Self :: Low) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RiskProbability { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RiskProbability { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RiskProbability { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "The root container for the entire software engineering project."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/software_application.schema.json\","] # [doc = "  \"title\": \"SoftwareApplication\","] # [doc = "  \"description\": \"The root container for the entire software engineering project.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"SoftwareApplication\""] # [doc = "        },"] # [doc = "        \"work_dir\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct SoftwareApplication { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : SoftwareApplicationKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub work_dir : :: std :: option :: Option < :: std :: string :: String > , } impl :: std :: convert :: From < & SoftwareApplication > for SoftwareApplication { fn from (value : & SoftwareApplication) -> Self { value . clone () } } impl SoftwareApplication { pub fn builder () -> builder :: SoftwareApplication { Default :: default () } } # [doc = "`SoftwareApplicationKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"SoftwareApplication\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum SoftwareApplicationKind { SoftwareApplication , } impl :: std :: convert :: From < & Self > for SoftwareApplicationKind { fn from (value : & SoftwareApplicationKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for SoftwareApplicationKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: SoftwareApplication => f . write_str ("SoftwareApplication") , } } } impl :: std :: str :: FromStr for SoftwareApplicationKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "SoftwareApplication" => Ok (Self :: SoftwareApplication) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for SoftwareApplicationKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for SoftwareApplicationKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for SoftwareApplicationKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Validation schemas for the Autonomous Coding Loop entities."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json\","] # [doc = "  \"title\": \"Software Engineering Taxonomy (Complete + Agents)\","] # [doc = "  \"description\": \"Validation schemas for the Autonomous Coding Loop entities.\","] # [doc = "  \"type\": \"object\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (transparent)] pub struct SoftwareEngineeringTaxonomyCompleteAgents (pub :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value >) ; impl :: std :: ops :: Deref for SoftwareEngineeringTaxonomyCompleteAgents { type Target = :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > ; fn deref (& self) -> & :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > { & self . 0 } } impl :: std :: convert :: From < SoftwareEngineeringTaxonomyCompleteAgents > for :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > { fn from (value : SoftwareEngineeringTaxonomyCompleteAgents) -> Self { value . 0 } } impl :: std :: convert :: From < & SoftwareEngineeringTaxonomyCompleteAgents > for SoftwareEngineeringTaxonomyCompleteAgents { fn from (value : & SoftwareEngineeringTaxonomyCompleteAgents) -> Self { value . clone () } } impl :: std :: convert :: From < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > for SoftwareEngineeringTaxonomyCompleteAgents { fn from (value : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value >) -> Self { Self (value) } } # [doc = "A file containing source code (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/source_file.schema.json\","] # [doc = "  \"title\": \"SourceFile\","] # [doc = "  \"description\": \"A file containing source code (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"language\","] # [doc = "        \"path\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"checksum\": {"] # [doc = "          \"description\": \"SHA-256 hash for integrity verification\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"content\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"SourceFile\""] # [doc = "        },"] # [doc = "        \"language\": {"] # [doc = "          \"description\": \"e.g., Rust, Python\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"language_version\": {"] # [doc = "          \"description\": \"e.g., 2021, 3.10\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"path\": {"] # [doc = "          \"description\": \"Relative path from project root\","] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct SourceFile { # [doc = "SHA-256 hash for integrity verification"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub checksum : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub content : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : SourceFileKind , # [doc = "e.g., Rust, Python"] pub language : :: std :: string :: String , # [doc = "e.g., 2021, 3.10"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub language_version : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Relative path from project root"] pub path : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & SourceFile > for SourceFile { fn from (value : & SourceFile) -> Self { value . clone () } } impl SourceFile { pub fn builder () -> builder :: SourceFile { Default :: default () } } # [doc = "`SourceFileKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"SourceFile\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum SourceFileKind { SourceFile , } impl :: std :: convert :: From < & Self > for SourceFileKind { fn from (value : & SourceFileKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for SourceFileKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: SourceFile => f . write_str ("SourceFile") , } } } impl :: std :: str :: FromStr for SourceFileKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "SourceFile" => Ok (Self :: SourceFile) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for SourceFileKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for SourceFileKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for SourceFileKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A rule or constraint that applies to the project."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/standard.schema.json\","] # [doc = "  \"title\": \"Standard\","] # [doc = "  \"description\": \"A rule or constraint that applies to the project.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"category\","] # [doc = "        \"kind\","] # [doc = "        \"rules\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"category\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Language\","] # [doc = "            \"Framework\","] # [doc = "            \"Style\","] # [doc = "            \"Testing\","] # [doc = "            \"Deployment\","] # [doc = "            \"Security\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"command_template\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"compliance_level\": {"] # [doc = "          \"default\": \"Mandatory\","] # [doc = "          \"enum\": ["] # [doc = "            \"Mandatory\","] # [doc = "            \"Recommended\","] # [doc = "            \"Optional\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"enforcement_tool\": {"] # [doc = "          \"description\": \"Tool used to enforce this (e.g., 'clippy', 'eslint')\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Standard\""] # [doc = "        },"] # [doc = "        \"rules\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Standard { pub category : StandardCategory , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub command_template : :: std :: option :: Option < :: std :: string :: String > , # [serde (default = "defaults::standard_compliance_level")] pub compliance_level : StandardComplianceLevel , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Tool used to enforce this (e.g., 'clippy', 'eslint')"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub enforcement_tool : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : StandardKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , pub rules : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Standard > for Standard { fn from (value : & Standard) -> Self { value . clone () } } impl Standard { pub fn builder () -> builder :: Standard { Default :: default () } } # [doc = "`StandardCategory`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Language\","] # [doc = "    \"Framework\","] # [doc = "    \"Style\","] # [doc = "    \"Testing\","] # [doc = "    \"Deployment\","] # [doc = "    \"Security\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum StandardCategory { Language , Framework , Style , Testing , Deployment , Security , } impl :: std :: convert :: From < & Self > for StandardCategory { fn from (value : & StandardCategory) -> Self { value . clone () } } impl :: std :: fmt :: Display for StandardCategory { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Language => f . write_str ("Language") , Self :: Framework => f . write_str ("Framework") , Self :: Style => f . write_str ("Style") , Self :: Testing => f . write_str ("Testing") , Self :: Deployment => f . write_str ("Deployment") , Self :: Security => f . write_str ("Security") , } } } impl :: std :: str :: FromStr for StandardCategory { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Language" => Ok (Self :: Language) , "Framework" => Ok (Self :: Framework) , "Style" => Ok (Self :: Style) , "Testing" => Ok (Self :: Testing) , "Deployment" => Ok (Self :: Deployment) , "Security" => Ok (Self :: Security) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for StandardCategory { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for StandardCategory { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for StandardCategory { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`StandardComplianceLevel`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"Mandatory\","] # [doc = "  \"enum\": ["] # [doc = "    \"Mandatory\","] # [doc = "    \"Recommended\","] # [doc = "    \"Optional\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum StandardComplianceLevel { Mandatory , Recommended , Optional , } impl :: std :: convert :: From < & Self > for StandardComplianceLevel { fn from (value : & StandardComplianceLevel) -> Self { value . clone () } } impl :: std :: fmt :: Display for StandardComplianceLevel { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Mandatory => f . write_str ("Mandatory") , Self :: Recommended => f . write_str ("Recommended") , Self :: Optional => f . write_str ("Optional") , } } } impl :: std :: str :: FromStr for StandardComplianceLevel { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Mandatory" => Ok (Self :: Mandatory) , "Recommended" => Ok (Self :: Recommended) , "Optional" => Ok (Self :: Optional) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for StandardComplianceLevel { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for StandardComplianceLevel { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for StandardComplianceLevel { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: default :: Default for StandardComplianceLevel { fn default () -> Self { StandardComplianceLevel :: Mandatory } } # [doc = "`StandardKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Standard\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum StandardKind { Standard , } impl :: std :: convert :: From < & Self > for StandardKind { fn from (value : & StandardKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for StandardKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Standard => f . write_str ("Standard") , } } } impl :: std :: str :: FromStr for StandardKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Standard" => Ok (Self :: Standard) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for StandardKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for StandardKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for StandardKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A specific technology item chosen for the project (e.g., 'React', 'Tokio')."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/tech_stack.schema.json\","] # [doc = "  \"title\": \"TechStack\","] # [doc = "  \"description\": \"A specific technology item chosen for the project (e.g., 'React', 'Tokio').\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"type\","] # [doc = "        \"version_constraint\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"TechStack\""] # [doc = "        },"] # [doc = "        \"reason\": {"] # [doc = "          \"description\": \"Ideally referencing an ADR or decision.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Language\","] # [doc = "            \"Framework\","] # [doc = "            \"Library\","] # [doc = "            \"Database\","] # [doc = "            \"Runtime\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"version_constraint\": {"] # [doc = "          \"description\": \"e.g., '^1.2.0'\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"website\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"uri\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct TechStack { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : TechStackKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Ideally referencing an ADR or decision."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub reason : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (rename = "type")] pub type_ : TechStackType , # [doc = "e.g., '^1.2.0'"] pub version_constraint : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub website : :: std :: option :: Option < :: std :: string :: String > , } impl :: std :: convert :: From < & TechStack > for TechStack { fn from (value : & TechStack) -> Self { value . clone () } } impl TechStack { pub fn builder () -> builder :: TechStack { Default :: default () } } # [doc = "`TechStackKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"TechStack\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TechStackKind { TechStack , } impl :: std :: convert :: From < & Self > for TechStackKind { fn from (value : & TechStackKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for TechStackKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: TechStack => f . write_str ("TechStack") , } } } impl :: std :: str :: FromStr for TechStackKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "TechStack" => Ok (Self :: TechStack) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TechStackKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TechStackKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TechStackKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`TechStackType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Language\","] # [doc = "    \"Framework\","] # [doc = "    \"Library\","] # [doc = "    \"Database\","] # [doc = "    \"Runtime\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TechStackType { Language , Framework , Library , Database , Runtime , } impl :: std :: convert :: From < & Self > for TechStackType { fn from (value : & TechStackType) -> Self { value . clone () } } impl :: std :: fmt :: Display for TechStackType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Language => f . write_str ("Language") , Self :: Framework => f . write_str ("Framework") , Self :: Library => f . write_str ("Library") , Self :: Database => f . write_str ("Database") , Self :: Runtime => f . write_str ("Runtime") , } } } impl :: std :: str :: FromStr for TechStackType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Language" => Ok (Self :: Language) , "Framework" => Ok (Self :: Framework) , "Library" => Ok (Self :: Library) , "Database" => Ok (Self :: Database) , "Runtime" => Ok (Self :: Runtime) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TechStackType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TechStackType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TechStackType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A verifiable test specification (SWEBOK: Software Testing)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/test_case.schema.json\","] # [doc = "  \"title\": \"TestCase\","] # [doc = "  \"description\": \"A verifiable test specification (SWEBOK: Software Testing).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"expected_result\","] # [doc = "        \"kind\","] # [doc = "        \"steps\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"expected_result\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"TestCase\""] # [doc = "        },"] # [doc = "        \"postconditions\": {"] # [doc = "          \"description\": \"State expected after the test (e.g., database cleanup).\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"preconditions\": {"] # [doc = "          \"description\": \"State required before running the test.\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"steps\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"test_data\": {"] # [doc = "          \"description\": \"Input data used for the test.\","] # [doc = "          \"type\": \"object\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct TestCase { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub expected_result : :: std :: string :: String , pub id : :: uuid :: Uuid , pub kind : TestCaseKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "State expected after the test (e.g., database cleanup)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub postconditions : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "State required before running the test."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub preconditions : :: std :: vec :: Vec < :: std :: string :: String > , pub steps : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Input data used for the test."] # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub test_data : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , } impl :: std :: convert :: From < & TestCase > for TestCase { fn from (value : & TestCase) -> Self { value . clone () } } impl TestCase { pub fn builder () -> builder :: TestCase { Default :: default () } } # [doc = "`TestCaseKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"TestCase\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TestCaseKind { TestCase , } impl :: std :: convert :: From < & Self > for TestCaseKind { fn from (value : & TestCaseKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for TestCaseKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: TestCase => f . write_str ("TestCase") , } } } impl :: std :: str :: FromStr for TestCaseKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "TestCase" => Ok (Self :: TestCase) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TestCaseKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TestCaseKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TestCaseKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "The outcome of a test case execution (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/test_result.schema.json\","] # [doc = "  \"title\": \"TestResult\","] # [doc = "  \"description\": \"The outcome of a test case execution (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"outcome\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"duration_ms\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"minimum\": 0.0"] # [doc = "        },"] # [doc = "        \"environment_ref\": {"] # [doc = "          \"description\": \"ID of the Environment where this ran\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"error_message\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"executed_at\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"date-time\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"TestResult\""] # [doc = "        },"] # [doc = "        \"logs\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"outcome\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Pass\","] # [doc = "            \"Fail\","] # [doc = "            \"Error\","] # [doc = "            \"Skipped\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct TestResult { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub duration_ms : :: std :: option :: Option < u64 > , # [doc = "ID of the Environment where this ran"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub environment_ref : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub error_message : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub executed_at : :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , pub id : :: uuid :: Uuid , pub kind : TestResultKind , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub logs : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , pub outcome : TestResultOutcome , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & TestResult > for TestResult { fn from (value : & TestResult) -> Self { value . clone () } } impl TestResult { pub fn builder () -> builder :: TestResult { Default :: default () } } # [doc = "`TestResultKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"TestResult\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TestResultKind { TestResult , } impl :: std :: convert :: From < & Self > for TestResultKind { fn from (value : & TestResultKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for TestResultKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: TestResult => f . write_str ("TestResult") , } } } impl :: std :: str :: FromStr for TestResultKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "TestResult" => Ok (Self :: TestResult) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TestResultKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TestResultKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TestResultKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`TestResultOutcome`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Pass\","] # [doc = "    \"Fail\","] # [doc = "    \"Error\","] # [doc = "    \"Skipped\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TestResultOutcome { Pass , Fail , Error , Skipped , } impl :: std :: convert :: From < & Self > for TestResultOutcome { fn from (value : & TestResultOutcome) -> Self { value . clone () } } impl :: std :: fmt :: Display for TestResultOutcome { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Pass => f . write_str ("Pass") , Self :: Fail => f . write_str ("Fail") , Self :: Error => f . write_str ("Error") , Self :: Skipped => f . write_str ("Skipped") , } } } impl :: std :: str :: FromStr for TestResultOutcome { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Pass" => Ok (Self :: Pass) , "Fail" => Ok (Self :: Fail) , "Error" => Ok (Self :: Error) , "Skipped" => Ok (Self :: Skipped) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TestResultOutcome { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TestResultOutcome { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TestResultOutcome { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A specific software tool or service required by the environment."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/tool.schema.json\","] # [doc = "  \"title\": \"Tool\","] # [doc = "  \"description\": \"A specific software tool or service required by the environment.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"category\","] # [doc = "        \"command_name\","] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"category\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Compiler\","] # [doc = "            \"Linter\","] # [doc = "            \"Database\","] # [doc = "            \"Server\","] # [doc = "            \"CLI\","] # [doc = "            \"Editor\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"command_name\": {"] # [doc = "          \"description\": \"The executable name (e.g., 'cargo', 'npm').\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"installation_guide\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Tool\""] # [doc = "        },"] # [doc = "        \"version_requirement\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Tool { pub category : ToolCategory , # [doc = "The executable name (e.g., 'cargo', 'npm')."] pub command_name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub installation_guide : :: std :: option :: Option < :: std :: string :: String > , pub kind : ToolKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub version_requirement : :: std :: option :: Option < :: std :: string :: String > , } impl :: std :: convert :: From < & Tool > for Tool { fn from (value : & Tool) -> Self { value . clone () } } impl Tool { pub fn builder () -> builder :: Tool { Default :: default () } } # [doc = "`ToolCategory`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Compiler\","] # [doc = "    \"Linter\","] # [doc = "    \"Database\","] # [doc = "    \"Server\","] # [doc = "    \"CLI\","] # [doc = "    \"Editor\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ToolCategory { Compiler , Linter , Database , Server , # [serde (rename = "CLI")] Cli , Editor , } impl :: std :: convert :: From < & Self > for ToolCategory { fn from (value : & ToolCategory) -> Self { value . clone () } } impl :: std :: fmt :: Display for ToolCategory { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Compiler => f . write_str ("Compiler") , Self :: Linter => f . write_str ("Linter") , Self :: Database => f . write_str ("Database") , Self :: Server => f . write_str ("Server") , Self :: Cli => f . write_str ("CLI") , Self :: Editor => f . write_str ("Editor") , } } } impl :: std :: str :: FromStr for ToolCategory { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Compiler" => Ok (Self :: Compiler) , "Linter" => Ok (Self :: Linter) , "Database" => Ok (Self :: Database) , "Server" => Ok (Self :: Server) , "CLI" => Ok (Self :: Cli) , "Editor" => Ok (Self :: Editor) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ToolCategory { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ToolCategory { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ToolCategory { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ToolKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Tool\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ToolKind { Tool , } impl :: std :: convert :: From < & Self > for ToolKind { fn from (value : & ToolKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ToolKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Tool => f . write_str ("Tool") , } } } impl :: std :: str :: FromStr for ToolKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Tool" => Ok (Self :: Tool) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ToolKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ToolKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ToolKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = r" Types for composing complex structures."] pub mod builder { # [derive (Clone , Debug)] pub struct Agent { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: AgentKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , responsibilities : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , role : :: std :: result :: Result < super :: AgentRole , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , system_prompt : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tools : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Agent { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , responsibilities : Err ("no value supplied for responsibilities" . to_string ()) , role : Err ("no value supplied for role" . to_string ()) , synonyms : Ok (Default :: default ()) , system_prompt : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , tools : Ok (Default :: default ()) , } } } impl Agent { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: AgentKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn responsibilities < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . responsibilities = value . try_into () . map_err (| e | format ! ("error converting supplied value for responsibilities: {}" , e)) ; self } pub fn role < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: AgentRole > , T :: Error : :: std :: fmt :: Display , { self . role = value . try_into () . map_err (| e | format ! ("error converting supplied value for role: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn system_prompt < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . system_prompt = value . try_into () . map_err (| e | format ! ("error converting supplied value for system_prompt: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn tools < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tools = value . try_into () . map_err (| e | format ! ("error converting supplied value for tools: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Agent > for super :: Agent { type Error = super :: error :: ConversionError ; fn try_from (value : Agent) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , responsibilities : value . responsibilities ? , role : value . role ? , synonyms : value . synonyms ? , system_prompt : value . system_prompt ? , tags : value . tags ? , tools : value . tools ? , }) } } impl :: std :: convert :: From < super :: Agent > for Agent { fn from (value : super :: Agent) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , responsibilities : Ok (value . responsibilities) , role : Ok (value . role) , synonyms : Ok (value . synonyms) , system_prompt : Ok (value . system_prompt) , tags : Ok (value . tags) , tools : Ok (value . tools) , } } } # [derive (Clone , Debug)] pub struct ArchitectureComponent { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ArchitectureComponentKind , :: std :: string :: String > , layer : :: std :: result :: Result < super :: ArchitectureComponentLayer , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for ArchitectureComponent { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , layer : Err ("no value supplied for layer" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl ArchitectureComponent { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ArchitectureComponentKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn layer < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ArchitectureComponentLayer > , T :: Error : :: std :: fmt :: Display , { self . layer = value . try_into () . map_err (| e | format ! ("error converting supplied value for layer: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < ArchitectureComponent > for super :: ArchitectureComponent { type Error = super :: error :: ConversionError ; fn try_from (value : ArchitectureComponent) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , layer : value . layer ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: ArchitectureComponent > for ArchitectureComponent { fn from (value : super :: ArchitectureComponent) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , layer : Ok (value . layer) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct ArchitecturePattern { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ArchitecturePatternKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , principles : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , structure_diagram : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , type_ : :: std :: result :: Result < super :: ArchitecturePatternType , :: std :: string :: String > , } impl :: std :: default :: Default for ArchitecturePattern { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , principles : Ok (Default :: default ()) , structure_diagram : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , type_ : Err ("no value supplied for type_" . to_string ()) , } } } impl ArchitecturePattern { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ArchitecturePatternKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn principles < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . principles = value . try_into () . map_err (| e | format ! ("error converting supplied value for principles: {}" , e)) ; self } pub fn structure_diagram < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . structure_diagram = value . try_into () . map_err (| e | format ! ("error converting supplied value for structure_diagram: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ArchitecturePatternType > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < ArchitecturePattern > for super :: ArchitecturePattern { type Error = super :: error :: ConversionError ; fn try_from (value : ArchitecturePattern) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , principles : value . principles ? , structure_diagram : value . structure_diagram ? , synonyms : value . synonyms ? , tags : value . tags ? , type_ : value . type_ ? , }) } } impl :: std :: convert :: From < super :: ArchitecturePattern > for ArchitecturePattern { fn from (value : super :: ArchitecturePattern) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , principles : Ok (value . principles) , structure_diagram : Ok (value . structure_diagram) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , type_ : Ok (value . type_) , } } } # [derive (Clone , Debug)] pub struct ChangeRequest { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ChangeRequestKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , reason : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , status : :: std :: result :: Result < super :: ChangeRequestStatus , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , target_entity_id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , } impl :: std :: default :: Default for ChangeRequest { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , reason : Ok (Default :: default ()) , status : Err ("no value supplied for status" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , target_entity_id : Err ("no value supplied for target_entity_id" . to_string ()) , } } } impl ChangeRequest { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ChangeRequestKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn reason < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . reason = value . try_into () . map_err (| e | format ! ("error converting supplied value for reason: {}" , e)) ; self } pub fn status < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ChangeRequestStatus > , T :: Error : :: std :: fmt :: Display , { self . status = value . try_into () . map_err (| e | format ! ("error converting supplied value for status: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn target_entity_id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . target_entity_id = value . try_into () . map_err (| e | format ! ("error converting supplied value for target_entity_id: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < ChangeRequest > for super :: ChangeRequest { type Error = super :: error :: ConversionError ; fn try_from (value : ChangeRequest) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , reason : value . reason ? , status : value . status ? , synonyms : value . synonyms ? , tags : value . tags ? , target_entity_id : value . target_entity_id ? , }) } } impl :: std :: convert :: From < super :: ChangeRequest > for ChangeRequest { fn from (value : super :: ChangeRequest) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , reason : Ok (value . reason) , status : Ok (value . status) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , target_entity_id : Ok (value . target_entity_id) , } } } # [derive (Clone , Debug)] pub struct Command { arguments : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , executable : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: CommandKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Command { fn default () -> Self { Self { arguments : Ok (Default :: default ()) , description : Ok (Default :: default ()) , executable : Err ("no value supplied for executable" . to_string ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Command { pub fn arguments < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . arguments = value . try_into () . map_err (| e | format ! ("error converting supplied value for arguments: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn executable < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . executable = value . try_into () . map_err (| e | format ! ("error converting supplied value for executable: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: CommandKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Command > for super :: Command { type Error = super :: error :: ConversionError ; fn try_from (value : Command) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { arguments : value . arguments ? , description : value . description ? , executable : value . executable ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Command > for Command { fn from (value : super :: Command) -> Self { Self { arguments : Ok (value . arguments) , description : Ok (value . description) , executable : Ok (value . executable) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct DataModel { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: DataModelKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , schema_definition : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for DataModel { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , schema_definition : Err ("no value supplied for schema_definition" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl DataModel { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: DataModelKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn schema_definition < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . schema_definition = value . try_into () . map_err (| e | format ! ("error converting supplied value for schema_definition: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DataModel > for super :: DataModel { type Error = super :: error :: ConversionError ; fn try_from (value : DataModel) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , schema_definition : value . schema_definition ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: DataModel > for DataModel { fn from (value : super :: DataModel) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , schema_definition : Ok (value . schema_definition) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct DesignSpec { data_spec : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: DesignSpecKind , :: std :: string :: String > , logic_spec : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , ui_spec : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , verification_plan : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for DesignSpec { fn default () -> Self { Self { data_spec : Ok (Default :: default ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , logic_spec : Ok (Default :: default ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , ui_spec : Ok (Default :: default ()) , verification_plan : Ok (Default :: default ()) , } } } impl DesignSpec { pub fn data_spec < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . data_spec = value . try_into () . map_err (| e | format ! ("error converting supplied value for data_spec: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: DesignSpecKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn logic_spec < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . logic_spec = value . try_into () . map_err (| e | format ! ("error converting supplied value for logic_spec: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn ui_spec < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . ui_spec = value . try_into () . map_err (| e | format ! ("error converting supplied value for ui_spec: {}" , e)) ; self } pub fn verification_plan < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . verification_plan = value . try_into () . map_err (| e | format ! ("error converting supplied value for verification_plan: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DesignSpec > for super :: DesignSpec { type Error = super :: error :: ConversionError ; fn try_from (value : DesignSpec) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { data_spec : value . data_spec ? , description : value . description ? , id : value . id ? , kind : value . kind ? , logic_spec : value . logic_spec ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , ui_spec : value . ui_spec ? , verification_plan : value . verification_plan ? , }) } } impl :: std :: convert :: From < super :: DesignSpec > for DesignSpec { fn from (value : super :: DesignSpec) -> Self { Self { data_spec : Ok (value . data_spec) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , logic_spec : Ok (value . logic_spec) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , ui_spec : Ok (value . ui_spec) , verification_plan : Ok (value . verification_plan) , } } } # [derive (Clone , Debug)] pub struct DomainEntity { attributes : :: std :: result :: Result < :: std :: vec :: Vec < super :: DomainEntityAttributesItem > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: DomainEntityKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , relationships : :: std :: result :: Result < :: std :: vec :: Vec < super :: DomainEntityRelationshipsItem > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for DomainEntity { fn default () -> Self { Self { attributes : Err ("no value supplied for attributes" . to_string ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , relationships : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl DomainEntity { pub fn attributes < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: DomainEntityAttributesItem > > , T :: Error : :: std :: fmt :: Display , { self . attributes = value . try_into () . map_err (| e | format ! ("error converting supplied value for attributes: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: DomainEntityKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn relationships < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: DomainEntityRelationshipsItem > > , T :: Error : :: std :: fmt :: Display , { self . relationships = value . try_into () . map_err (| e | format ! ("error converting supplied value for relationships: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DomainEntity > for super :: DomainEntity { type Error = super :: error :: ConversionError ; fn try_from (value : DomainEntity) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { attributes : value . attributes ? , description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , relationships : value . relationships ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: DomainEntity > for DomainEntity { fn from (value : super :: DomainEntity) -> Self { Self { attributes : Ok (value . attributes) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , relationships : Ok (value . relationships) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct DomainEntityAttributesItem { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , is_primary_key : :: std :: result :: Result < :: std :: option :: Option < bool > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , required : :: std :: result :: Result < :: std :: option :: Option < bool > , :: std :: string :: String > , type_ : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for DomainEntityAttributesItem { fn default () -> Self { Self { description : Ok (Default :: default ()) , is_primary_key : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , required : Ok (Default :: default ()) , type_ : Err ("no value supplied for type_" . to_string ()) , } } } impl DomainEntityAttributesItem { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn is_primary_key < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < bool > > , T :: Error : :: std :: fmt :: Display , { self . is_primary_key = value . try_into () . map_err (| e | format ! ("error converting supplied value for is_primary_key: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn required < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < bool > > , T :: Error : :: std :: fmt :: Display , { self . required = value . try_into () . map_err (| e | format ! ("error converting supplied value for required: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DomainEntityAttributesItem > for super :: DomainEntityAttributesItem { type Error = super :: error :: ConversionError ; fn try_from (value : DomainEntityAttributesItem) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , is_primary_key : value . is_primary_key ? , name : value . name ? , required : value . required ? , type_ : value . type_ ? , }) } } impl :: std :: convert :: From < super :: DomainEntityAttributesItem > for DomainEntityAttributesItem { fn from (value : super :: DomainEntityAttributesItem) -> Self { Self { description : Ok (value . description) , is_primary_key : Ok (value . is_primary_key) , name : Ok (value . name) , required : Ok (value . required) , type_ : Ok (value . type_) , } } } # [derive (Clone , Debug)] pub struct DomainEntityRelationshipsItem { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , relation_type : :: std :: result :: Result < super :: DomainEntityRelationshipsItemRelationType , :: std :: string :: String > , target_entity : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for DomainEntityRelationshipsItem { fn default () -> Self { Self { description : Ok (Default :: default ()) , relation_type : Err ("no value supplied for relation_type" . to_string ()) , target_entity : Err ("no value supplied for target_entity" . to_string ()) , } } } impl DomainEntityRelationshipsItem { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn relation_type < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: DomainEntityRelationshipsItemRelationType > , T :: Error : :: std :: fmt :: Display , { self . relation_type = value . try_into () . map_err (| e | format ! ("error converting supplied value for relation_type: {}" , e)) ; self } pub fn target_entity < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . target_entity = value . try_into () . map_err (| e | format ! ("error converting supplied value for target_entity: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DomainEntityRelationshipsItem > for super :: DomainEntityRelationshipsItem { type Error = super :: error :: ConversionError ; fn try_from (value : DomainEntityRelationshipsItem) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , relation_type : value . relation_type ? , target_entity : value . target_entity ? , }) } } impl :: std :: convert :: From < super :: DomainEntityRelationshipsItem > for DomainEntityRelationshipsItem { fn from (value : super :: DomainEntityRelationshipsItem) -> Self { Self { description : Ok (value . description) , relation_type : Ok (value . relation_type) , target_entity : Ok (value . target_entity) , } } } # [derive (Clone , Debug)] pub struct EntityMetadata { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for EntityMetadata { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl EntityMetadata { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < EntityMetadata > for super :: EntityMetadata { type Error = super :: error :: ConversionError ; fn try_from (value : EntityMetadata) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: EntityMetadata > for EntityMetadata { fn from (value : super :: EntityMetadata) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Environment { container_image : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , env_variables : :: std :: result :: Result < :: std :: collections :: HashMap < :: std :: string :: String , :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: EnvironmentKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , os : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , secrets : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tools : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , type_ : :: std :: result :: Result < super :: EnvironmentType , :: std :: string :: String > , } impl :: std :: default :: Default for Environment { fn default () -> Self { Self { container_image : Ok (Default :: default ()) , description : Ok (Default :: default ()) , env_variables : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , os : Ok (Default :: default ()) , secrets : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , tools : Ok (Default :: default ()) , type_ : Err ("no value supplied for type_" . to_string ()) , } } } impl Environment { pub fn container_image < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . container_image = value . try_into () . map_err (| e | format ! ("error converting supplied value for container_image: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn env_variables < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: collections :: HashMap < :: std :: string :: String , :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . env_variables = value . try_into () . map_err (| e | format ! ("error converting supplied value for env_variables: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: EnvironmentKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn os < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . os = value . try_into () . map_err (| e | format ! ("error converting supplied value for os: {}" , e)) ; self } pub fn secrets < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . secrets = value . try_into () . map_err (| e | format ! ("error converting supplied value for secrets: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn tools < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tools = value . try_into () . map_err (| e | format ! ("error converting supplied value for tools: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: EnvironmentType > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Environment > for super :: Environment { type Error = super :: error :: ConversionError ; fn try_from (value : Environment) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { container_image : value . container_image ? , description : value . description ? , env_variables : value . env_variables ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , os : value . os ? , secrets : value . secrets ? , synonyms : value . synonyms ? , tags : value . tags ? , tools : value . tools ? , type_ : value . type_ ? , }) } } impl :: std :: convert :: From < super :: Environment > for Environment { fn from (value : super :: Environment) -> Self { Self { container_image : Ok (value . container_image) , description : Ok (value . description) , env_variables : Ok (value . env_variables) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , os : Ok (value . os) , secrets : Ok (value . secrets) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , tools : Ok (value . tools) , type_ : Ok (value . type_) , } } } # [derive (Clone , Debug)] pub struct Feature { business_value : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: FeatureKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , priority : :: std :: result :: Result < super :: FeaturePriority , :: std :: string :: String > , status : :: std :: result :: Result < super :: FeatureStatus , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Feature { fn default () -> Self { Self { business_value : Err ("no value supplied for business_value" . to_string ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , priority : Err ("no value supplied for priority" . to_string ()) , status : Ok (super :: defaults :: feature_status ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Feature { pub fn business_value < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . business_value = value . try_into () . map_err (| e | format ! ("error converting supplied value for business_value: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: FeatureKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn priority < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: FeaturePriority > , T :: Error : :: std :: fmt :: Display , { self . priority = value . try_into () . map_err (| e | format ! ("error converting supplied value for priority: {}" , e)) ; self } pub fn status < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: FeatureStatus > , T :: Error : :: std :: fmt :: Display , { self . status = value . try_into () . map_err (| e | format ! ("error converting supplied value for status: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Feature > for super :: Feature { type Error = super :: error :: ConversionError ; fn try_from (value : Feature) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { business_value : value . business_value ? , description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , priority : value . priority ? , status : value . status ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Feature > for Feature { fn from (value : super :: Feature) -> Self { Self { business_value : Ok (value . business_value) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , priority : Ok (value . priority) , status : Ok (value . status) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct FileSystemNode { children : :: std :: result :: Result < :: std :: vec :: Vec < super :: FileSystemNode > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , type_ : :: std :: result :: Result < super :: FileSystemNodeType , :: std :: string :: String > , } impl :: std :: default :: Default for FileSystemNode { fn default () -> Self { Self { children : Ok (Default :: default ()) , description : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , type_ : Err ("no value supplied for type_" . to_string ()) , } } } impl FileSystemNode { pub fn children < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: FileSystemNode > > , T :: Error : :: std :: fmt :: Display , { self . children = value . try_into () . map_err (| e | format ! ("error converting supplied value for children: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: FileSystemNodeType > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < FileSystemNode > for super :: FileSystemNode { type Error = super :: error :: ConversionError ; fn try_from (value : FileSystemNode) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { children : value . children ? , description : value . description ? , name : value . name ? , type_ : value . type_ ? , }) } } impl :: std :: convert :: From < super :: FileSystemNode > for FileSystemNode { fn from (value : super :: FileSystemNode) -> Self { Self { children : Ok (value . children) , description : Ok (value . description) , name : Ok (value . name) , type_ : Ok (value . type_) , } } } # [derive (Clone , Debug)] pub struct Observation { artifact_id : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , context : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , insight : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ObservationKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , observed_at : :: std :: result :: Result < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , :: std :: string :: String > , recommendation : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , severity : :: std :: result :: Result < super :: ObservationSeverity , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Observation { fn default () -> Self { Self { artifact_id : Ok (Default :: default ()) , context : Ok (Default :: default ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , insight : Err ("no value supplied for insight" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , observed_at : Ok (Default :: default ()) , recommendation : Ok (Default :: default ()) , severity : Err ("no value supplied for severity" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Observation { pub fn artifact_id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . artifact_id = value . try_into () . map_err (| e | format ! ("error converting supplied value for artifact_id: {}" , e)) ; self } pub fn context < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . context = value . try_into () . map_err (| e | format ! ("error converting supplied value for context: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn insight < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . insight = value . try_into () . map_err (| e | format ! ("error converting supplied value for insight: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ObservationKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn observed_at < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > > , T :: Error : :: std :: fmt :: Display , { self . observed_at = value . try_into () . map_err (| e | format ! ("error converting supplied value for observed_at: {}" , e)) ; self } pub fn recommendation < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . recommendation = value . try_into () . map_err (| e | format ! ("error converting supplied value for recommendation: {}" , e)) ; self } pub fn severity < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ObservationSeverity > , T :: Error : :: std :: fmt :: Display , { self . severity = value . try_into () . map_err (| e | format ! ("error converting supplied value for severity: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Observation > for super :: Observation { type Error = super :: error :: ConversionError ; fn try_from (value : Observation) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { artifact_id : value . artifact_id ? , context : value . context ? , description : value . description ? , id : value . id ? , insight : value . insight ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , observed_at : value . observed_at ? , recommendation : value . recommendation ? , severity : value . severity ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Observation > for Observation { fn from (value : super :: Observation) -> Self { Self { artifact_id : Ok (value . artifact_id) , context : Ok (value . context) , description : Ok (value . description) , id : Ok (value . id) , insight : Ok (value . insight) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , observed_at : Ok (value . observed_at) , recommendation : Ok (value . recommendation) , severity : Ok (value . severity) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Persona { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: PersonaKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , responsibilities : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , role : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Persona { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , responsibilities : Ok (Default :: default ()) , role : Err ("no value supplied for role" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Persona { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: PersonaKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn responsibilities < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . responsibilities = value . try_into () . map_err (| e | format ! ("error converting supplied value for responsibilities: {}" , e)) ; self } pub fn role < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . role = value . try_into () . map_err (| e | format ! ("error converting supplied value for role: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Persona > for super :: Persona { type Error = super :: error :: ConversionError ; fn try_from (value : Persona) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , responsibilities : value . responsibilities ? , role : value . role ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Persona > for Persona { fn from (value : super :: Persona) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , responsibilities : Ok (value . responsibilities) , role : Ok (value . role) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Plan { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: PlanKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tasks : :: std :: result :: Result < :: std :: vec :: Vec < super :: PlanTasksItem > , :: std :: string :: String > , } impl :: std :: default :: Default for Plan { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , tasks : Err ("no value supplied for tasks" . to_string ()) , } } } impl Plan { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: PlanKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn tasks < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: PlanTasksItem > > , T :: Error : :: std :: fmt :: Display , { self . tasks = value . try_into () . map_err (| e | format ! ("error converting supplied value for tasks: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Plan > for super :: Plan { type Error = super :: error :: ConversionError ; fn try_from (value : Plan) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , tasks : value . tasks ? , }) } } impl :: std :: convert :: From < super :: Plan > for Plan { fn from (value : super :: Plan) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , tasks : Ok (value . tasks) , } } } # [derive (Clone , Debug)] pub struct PlanTasksItem { dependencies : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , estimated_duration : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for PlanTasksItem { fn default () -> Self { Self { dependencies : Ok (Default :: default ()) , description : Err ("no value supplied for description" . to_string ()) , estimated_duration : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , } } } impl PlanTasksItem { pub fn dependencies < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . dependencies = value . try_into () . map_err (| e | format ! ("error converting supplied value for dependencies: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn estimated_duration < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . estimated_duration = value . try_into () . map_err (| e | format ! ("error converting supplied value for estimated_duration: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < PlanTasksItem > for super :: PlanTasksItem { type Error = super :: error :: ConversionError ; fn try_from (value : PlanTasksItem) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { dependencies : value . dependencies ? , description : value . description ? , estimated_duration : value . estimated_duration ? , id : value . id ? , }) } } impl :: std :: convert :: From < super :: PlanTasksItem > for PlanTasksItem { fn from (value : super :: PlanTasksItem) -> Self { Self { dependencies : Ok (value . dependencies) , description : Ok (value . description) , estimated_duration : Ok (value . estimated_duration) , id : Ok (value . id) , } } } # [derive (Clone , Debug)] pub struct ProjectStructure { conventions : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ProjectStructureKind , :: std :: string :: String > , layout : :: std :: result :: Result < :: std :: vec :: Vec < super :: FileSystemNode > , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , root_path : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for ProjectStructure { fn default () -> Self { Self { conventions : Ok (Default :: default ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , layout : Err ("no value supplied for layout" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , root_path : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl ProjectStructure { pub fn conventions < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . conventions = value . try_into () . map_err (| e | format ! ("error converting supplied value for conventions: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ProjectStructureKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn layout < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: FileSystemNode > > , T :: Error : :: std :: fmt :: Display , { self . layout = value . try_into () . map_err (| e | format ! ("error converting supplied value for layout: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn root_path < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . root_path = value . try_into () . map_err (| e | format ! ("error converting supplied value for root_path: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < ProjectStructure > for super :: ProjectStructure { type Error = super :: error :: ConversionError ; fn try_from (value : ProjectStructure) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { conventions : value . conventions ? , description : value . description ? , id : value . id ? , kind : value . kind ? , layout : value . layout ? , metadata : value . metadata ? , name : value . name ? , root_path : value . root_path ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: ProjectStructure > for ProjectStructure { fn from (value : super :: ProjectStructure) -> Self { Self { conventions : Ok (value . conventions) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , layout : Ok (value . layout) , metadata : Ok (value . metadata) , name : Ok (value . name) , root_path : Ok (value . root_path) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Requirement { acceptance_criteria : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: RequirementKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , priority : :: std :: result :: Result < :: std :: option :: Option < super :: RequirementPriority > , :: std :: string :: String > , req_type : :: std :: result :: Result < super :: RequirementReqType , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , user_story : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for Requirement { fn default () -> Self { Self { acceptance_criteria : Err ("no value supplied for acceptance_criteria" . to_string ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , priority : Ok (Default :: default ()) , req_type : Err ("no value supplied for req_type" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , user_story : Err ("no value supplied for user_story" . to_string ()) , } } } impl Requirement { pub fn acceptance_criteria < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . acceptance_criteria = value . try_into () . map_err (| e | format ! ("error converting supplied value for acceptance_criteria: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RequirementKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn priority < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < super :: RequirementPriority > > , T :: Error : :: std :: fmt :: Display , { self . priority = value . try_into () . map_err (| e | format ! ("error converting supplied value for priority: {}" , e)) ; self } pub fn req_type < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RequirementReqType > , T :: Error : :: std :: fmt :: Display , { self . req_type = value . try_into () . map_err (| e | format ! ("error converting supplied value for req_type: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn user_story < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . user_story = value . try_into () . map_err (| e | format ! ("error converting supplied value for user_story: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Requirement > for super :: Requirement { type Error = super :: error :: ConversionError ; fn try_from (value : Requirement) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { acceptance_criteria : value . acceptance_criteria ? , description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , priority : value . priority ? , req_type : value . req_type ? , synonyms : value . synonyms ? , tags : value . tags ? , user_story : value . user_story ? , }) } } impl :: std :: convert :: From < super :: Requirement > for Requirement { fn from (value : super :: Requirement) -> Self { Self { acceptance_criteria : Ok (value . acceptance_criteria) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , priority : Ok (value . priority) , req_type : Ok (value . req_type) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , user_story : Ok (value . user_story) , } } } # [derive (Clone , Debug)] pub struct Risk { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , impact : :: std :: result :: Result < super :: RiskImpact , :: std :: string :: String > , kind : :: std :: result :: Result < super :: RiskKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , mitigation_plan : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , probability : :: std :: result :: Result < super :: RiskProbability , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Risk { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , impact : Err ("no value supplied for impact" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , mitigation_plan : Err ("no value supplied for mitigation_plan" . to_string ()) , name : Err ("no value supplied for name" . to_string ()) , probability : Err ("no value supplied for probability" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Risk { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn impact < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RiskImpact > , T :: Error : :: std :: fmt :: Display , { self . impact = value . try_into () . map_err (| e | format ! ("error converting supplied value for impact: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RiskKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn mitigation_plan < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . mitigation_plan = value . try_into () . map_err (| e | format ! ("error converting supplied value for mitigation_plan: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn probability < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RiskProbability > , T :: Error : :: std :: fmt :: Display , { self . probability = value . try_into () . map_err (| e | format ! ("error converting supplied value for probability: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Risk > for super :: Risk { type Error = super :: error :: ConversionError ; fn try_from (value : Risk) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , impact : value . impact ? , kind : value . kind ? , metadata : value . metadata ? , mitigation_plan : value . mitigation_plan ? , name : value . name ? , probability : value . probability ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Risk > for Risk { fn from (value : super :: Risk) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , impact : Ok (value . impact) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , mitigation_plan : Ok (value . mitigation_plan) , name : Ok (value . name) , probability : Ok (value . probability) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct SoftwareApplication { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: SoftwareApplicationKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , work_dir : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for SoftwareApplication { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , work_dir : Ok (Default :: default ()) , } } } impl SoftwareApplication { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: SoftwareApplicationKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn work_dir < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . work_dir = value . try_into () . map_err (| e | format ! ("error converting supplied value for work_dir: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < SoftwareApplication > for super :: SoftwareApplication { type Error = super :: error :: ConversionError ; fn try_from (value : SoftwareApplication) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , work_dir : value . work_dir ? , }) } } impl :: std :: convert :: From < super :: SoftwareApplication > for SoftwareApplication { fn from (value : super :: SoftwareApplication) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , work_dir : Ok (value . work_dir) , } } } # [derive (Clone , Debug)] pub struct SourceFile { checksum : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , content : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: SourceFileKind , :: std :: string :: String > , language : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , language_version : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , path : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for SourceFile { fn default () -> Self { Self { checksum : Ok (Default :: default ()) , content : Ok (Default :: default ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , language : Err ("no value supplied for language" . to_string ()) , language_version : Ok (Default :: default ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , path : Err ("no value supplied for path" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl SourceFile { pub fn checksum < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . checksum = value . try_into () . map_err (| e | format ! ("error converting supplied value for checksum: {}" , e)) ; self } pub fn content < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . content = value . try_into () . map_err (| e | format ! ("error converting supplied value for content: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: SourceFileKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn language < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . language = value . try_into () . map_err (| e | format ! ("error converting supplied value for language: {}" , e)) ; self } pub fn language_version < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . language_version = value . try_into () . map_err (| e | format ! ("error converting supplied value for language_version: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn path < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . path = value . try_into () . map_err (| e | format ! ("error converting supplied value for path: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < SourceFile > for super :: SourceFile { type Error = super :: error :: ConversionError ; fn try_from (value : SourceFile) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { checksum : value . checksum ? , content : value . content ? , description : value . description ? , id : value . id ? , kind : value . kind ? , language : value . language ? , language_version : value . language_version ? , metadata : value . metadata ? , name : value . name ? , path : value . path ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: SourceFile > for SourceFile { fn from (value : super :: SourceFile) -> Self { Self { checksum : Ok (value . checksum) , content : Ok (value . content) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , language : Ok (value . language) , language_version : Ok (value . language_version) , metadata : Ok (value . metadata) , name : Ok (value . name) , path : Ok (value . path) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Standard { category : :: std :: result :: Result < super :: StandardCategory , :: std :: string :: String > , command_template : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , compliance_level : :: std :: result :: Result < super :: StandardComplianceLevel , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , enforcement_tool : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: StandardKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , rules : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Standard { fn default () -> Self { Self { category : Err ("no value supplied for category" . to_string ()) , command_template : Ok (Default :: default ()) , compliance_level : Ok (super :: defaults :: standard_compliance_level ()) , description : Ok (Default :: default ()) , enforcement_tool : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , rules : Err ("no value supplied for rules" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Standard { pub fn category < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: StandardCategory > , T :: Error : :: std :: fmt :: Display , { self . category = value . try_into () . map_err (| e | format ! ("error converting supplied value for category: {}" , e)) ; self } pub fn command_template < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . command_template = value . try_into () . map_err (| e | format ! ("error converting supplied value for command_template: {}" , e)) ; self } pub fn compliance_level < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: StandardComplianceLevel > , T :: Error : :: std :: fmt :: Display , { self . compliance_level = value . try_into () . map_err (| e | format ! ("error converting supplied value for compliance_level: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn enforcement_tool < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . enforcement_tool = value . try_into () . map_err (| e | format ! ("error converting supplied value for enforcement_tool: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: StandardKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn rules < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . rules = value . try_into () . map_err (| e | format ! ("error converting supplied value for rules: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Standard > for super :: Standard { type Error = super :: error :: ConversionError ; fn try_from (value : Standard) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { category : value . category ? , command_template : value . command_template ? , compliance_level : value . compliance_level ? , description : value . description ? , enforcement_tool : value . enforcement_tool ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , rules : value . rules ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Standard > for Standard { fn from (value : super :: Standard) -> Self { Self { category : Ok (value . category) , command_template : Ok (value . command_template) , compliance_level : Ok (value . compliance_level) , description : Ok (value . description) , enforcement_tool : Ok (value . enforcement_tool) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , rules : Ok (value . rules) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct TechStack { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: TechStackKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , reason : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , type_ : :: std :: result :: Result < super :: TechStackType , :: std :: string :: String > , version_constraint : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , website : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for TechStack { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , reason : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , type_ : Err ("no value supplied for type_" . to_string ()) , version_constraint : Err ("no value supplied for version_constraint" . to_string ()) , website : Ok (Default :: default ()) , } } } impl TechStack { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TechStackKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn reason < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . reason = value . try_into () . map_err (| e | format ! ("error converting supplied value for reason: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TechStackType > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } pub fn version_constraint < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . version_constraint = value . try_into () . map_err (| e | format ! ("error converting supplied value for version_constraint: {}" , e)) ; self } pub fn website < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . website = value . try_into () . map_err (| e | format ! ("error converting supplied value for website: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < TechStack > for super :: TechStack { type Error = super :: error :: ConversionError ; fn try_from (value : TechStack) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , reason : value . reason ? , synonyms : value . synonyms ? , tags : value . tags ? , type_ : value . type_ ? , version_constraint : value . version_constraint ? , website : value . website ? , }) } } impl :: std :: convert :: From < super :: TechStack > for TechStack { fn from (value : super :: TechStack) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , reason : Ok (value . reason) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , type_ : Ok (value . type_) , version_constraint : Ok (value . version_constraint) , website : Ok (value . website) , } } } # [derive (Clone , Debug)] pub struct TestCase { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , expected_result : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: TestCaseKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , postconditions : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , preconditions : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , steps : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , test_data : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , } impl :: std :: default :: Default for TestCase { fn default () -> Self { Self { description : Ok (Default :: default ()) , expected_result : Err ("no value supplied for expected_result" . to_string ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , postconditions : Ok (Default :: default ()) , preconditions : Ok (Default :: default ()) , steps : Err ("no value supplied for steps" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , test_data : Ok (Default :: default ()) , } } } impl TestCase { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn expected_result < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . expected_result = value . try_into () . map_err (| e | format ! ("error converting supplied value for expected_result: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TestCaseKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn postconditions < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . postconditions = value . try_into () . map_err (| e | format ! ("error converting supplied value for postconditions: {}" , e)) ; self } pub fn preconditions < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . preconditions = value . try_into () . map_err (| e | format ! ("error converting supplied value for preconditions: {}" , e)) ; self } pub fn steps < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . steps = value . try_into () . map_err (| e | format ! ("error converting supplied value for steps: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn test_data < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . test_data = value . try_into () . map_err (| e | format ! ("error converting supplied value for test_data: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < TestCase > for super :: TestCase { type Error = super :: error :: ConversionError ; fn try_from (value : TestCase) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , expected_result : value . expected_result ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , postconditions : value . postconditions ? , preconditions : value . preconditions ? , steps : value . steps ? , synonyms : value . synonyms ? , tags : value . tags ? , test_data : value . test_data ? , }) } } impl :: std :: convert :: From < super :: TestCase > for TestCase { fn from (value : super :: TestCase) -> Self { Self { description : Ok (value . description) , expected_result : Ok (value . expected_result) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , postconditions : Ok (value . postconditions) , preconditions : Ok (value . preconditions) , steps : Ok (value . steps) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , test_data : Ok (value . test_data) , } } } # [derive (Clone , Debug)] pub struct TestResult { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , duration_ms : :: std :: result :: Result < :: std :: option :: Option < u64 > , :: std :: string :: String > , environment_ref : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , error_message : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , executed_at : :: std :: result :: Result < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: TestResultKind , :: std :: string :: String > , logs : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , outcome : :: std :: result :: Result < super :: TestResultOutcome , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for TestResult { fn default () -> Self { Self { description : Ok (Default :: default ()) , duration_ms : Ok (Default :: default ()) , environment_ref : Ok (Default :: default ()) , error_message : Ok (Default :: default ()) , executed_at : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , logs : Ok (Default :: default ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , outcome : Err ("no value supplied for outcome" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl TestResult { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn duration_ms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < u64 > > , T :: Error : :: std :: fmt :: Display , { self . duration_ms = value . try_into () . map_err (| e | format ! ("error converting supplied value for duration_ms: {}" , e)) ; self } pub fn environment_ref < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . environment_ref = value . try_into () . map_err (| e | format ! ("error converting supplied value for environment_ref: {}" , e)) ; self } pub fn error_message < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . error_message = value . try_into () . map_err (| e | format ! ("error converting supplied value for error_message: {}" , e)) ; self } pub fn executed_at < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > > , T :: Error : :: std :: fmt :: Display , { self . executed_at = value . try_into () . map_err (| e | format ! ("error converting supplied value for executed_at: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TestResultKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn logs < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . logs = value . try_into () . map_err (| e | format ! ("error converting supplied value for logs: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn outcome < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TestResultOutcome > , T :: Error : :: std :: fmt :: Display , { self . outcome = value . try_into () . map_err (| e | format ! ("error converting supplied value for outcome: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < TestResult > for super :: TestResult { type Error = super :: error :: ConversionError ; fn try_from (value : TestResult) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , duration_ms : value . duration_ms ? , environment_ref : value . environment_ref ? , error_message : value . error_message ? , executed_at : value . executed_at ? , id : value . id ? , kind : value . kind ? , logs : value . logs ? , metadata : value . metadata ? , name : value . name ? , outcome : value . outcome ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: TestResult > for TestResult { fn from (value : super :: TestResult) -> Self { Self { description : Ok (value . description) , duration_ms : Ok (value . duration_ms) , environment_ref : Ok (value . environment_ref) , error_message : Ok (value . error_message) , executed_at : Ok (value . executed_at) , id : Ok (value . id) , kind : Ok (value . kind) , logs : Ok (value . logs) , metadata : Ok (value . metadata) , name : Ok (value . name) , outcome : Ok (value . outcome) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Tool { category : :: std :: result :: Result < super :: ToolCategory , :: std :: string :: String > , command_name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , installation_guide : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ToolKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , version_requirement : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Tool { fn default () -> Self { Self { category : Err ("no value supplied for category" . to_string ()) , command_name : Err ("no value supplied for command_name" . to_string ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , installation_guide : Ok (Default :: default ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , version_requirement : Ok (Default :: default ()) , } } } impl Tool { pub fn category < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ToolCategory > , T :: Error : :: std :: fmt :: Display , { self . category = value . try_into () . map_err (| e | format ! ("error converting supplied value for category: {}" , e)) ; self } pub fn command_name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . command_name = value . try_into () . map_err (| e | format ! ("error converting supplied value for command_name: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn installation_guide < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . installation_guide = value . try_into () . map_err (| e | format ! ("error converting supplied value for installation_guide: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ToolKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn version_requirement < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . version_requirement = value . try_into () . map_err (| e | format ! ("error converting supplied value for version_requirement: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Tool > for super :: Tool { type Error = super :: error :: ConversionError ; fn try_from (value : Tool) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { category : value . category ? , command_name : value . command_name ? , description : value . description ? , id : value . id ? , installation_guide : value . installation_guide ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , version_requirement : value . version_requirement ? , }) } } impl :: std :: convert :: From < super :: Tool > for Tool { fn from (value : super :: Tool) -> Self { Self { category : Ok (value . category) , command_name : Ok (value . command_name) , description : Ok (value . description) , id : Ok (value . id) , installation_guide : Ok (value . installation_guide) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , version_requirement : Ok (value . version_requirement) , } } } } # [doc = r" Generation of default values for serde."] pub mod defaults { pub (super) fn feature_status () -> super :: FeatureStatus { super :: FeatureStatus :: Proposed } pub (super) fn standard_compliance_level () -> super :: StandardComplianceLevel { super :: StandardComplianceLevel :: Mandatory } }
  |

error: this `impl` can be derived
 --> /home/dev/repos/infinite-coding-loop/target/debug/build/dass-engine-31d7b5bbc214e41e/out/domain_types.rs:1:147055
  |
1 | ... } impl :: std :: default :: Default for StandardComplianceLevel { fn default () -> Self { StandardComplianceLevel :: Mandatory } } # ...
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: for further information visit https://rust-lang.github.io/rust-clippy/rust-1.92.0/index.html#derivable_impls
help: replace the manual implementation with a derive attribute and mark the default variant
  |
1 ~ # [doc = r" Error types."] pub mod error { # [doc = r" Error from a `TryFrom` or `FromStr` implementation."] pub struct ConversionError (:: std :: borrow :: Cow < 'static , str >) ; impl :: std :: error :: Error for ConversionError { } impl :: std :: fmt :: Display for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Display :: fmt (& self . 0 , f) } } impl :: std :: fmt :: Debug for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Debug :: fmt (& self . 0 , f) } } impl From < & 'static str > for ConversionError { fn from (value : & 'static str) -> Self { Self (value . into ()) } } impl From < String > for ConversionError { fn from (value : String) -> Self { Self (value . into ()) } } } # [doc = "An AI worker responsible for creating specific artifacts (The 'Who')."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/agent.schema.json\","] # [doc = "  \"title\": \"Agent\","] # [doc = "  \"description\": \"An AI worker responsible for creating specific artifacts (The 'Who').\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"responsibilities\","] # [doc = "        \"role\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Agent\""] # [doc = "        },"] # [doc = "        \"responsibilities\": {"] # [doc = "          \"description\": \"List of Entity kinds this agent produces (e.g., 'Requirement', 'Plan').\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"role\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"ProductManager\","] # [doc = "            \"Architect\","] # [doc = "            \"Engineer\","] # [doc = "            \"QA\","] # [doc = "            \"Manager\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"system_prompt\": {"] # [doc = "          \"description\": \"The personality and constraints for this agent.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"tools\": {"] # [doc = "          \"description\": \"List of allowed tools (e.g., 'search_web', 'write_file').\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Agent { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : AgentKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "List of Entity kinds this agent produces (e.g., 'Requirement', 'Plan')."] pub responsibilities : :: std :: vec :: Vec < :: std :: string :: String > , pub role : AgentRole , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "The personality and constraints for this agent."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub system_prompt : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "List of allowed tools (e.g., 'search_web', 'write_file')."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tools : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Agent > for Agent { fn from (value : & Agent) -> Self { value . clone () } } impl Agent { pub fn builder () -> builder :: Agent { Default :: default () } } # [doc = "`AgentKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Agent\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum AgentKind { Agent , } impl :: std :: convert :: From < & Self > for AgentKind { fn from (value : & AgentKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for AgentKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Agent => f . write_str ("Agent") , } } } impl :: std :: str :: FromStr for AgentKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Agent" => Ok (Self :: Agent) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for AgentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for AgentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for AgentKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`AgentRole`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"ProductManager\","] # [doc = "    \"Architect\","] # [doc = "    \"Engineer\","] # [doc = "    \"QA\","] # [doc = "    \"Manager\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum AgentRole { ProductManager , Architect , Engineer , # [serde (rename = "QA")] Qa , Manager , } impl :: std :: convert :: From < & Self > for AgentRole { fn from (value : & AgentRole) -> Self { value . clone () } } impl :: std :: fmt :: Display for AgentRole { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ProductManager => f . write_str ("ProductManager") , Self :: Architect => f . write_str ("Architect") , Self :: Engineer => f . write_str ("Engineer") , Self :: Qa => f . write_str ("QA") , Self :: Manager => f . write_str ("Manager") , } } } impl :: std :: str :: FromStr for AgentRole { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ProductManager" => Ok (Self :: ProductManager) , "Architect" => Ok (Self :: Architect) , "Engineer" => Ok (Self :: Engineer) , "QA" => Ok (Self :: Qa) , "Manager" => Ok (Self :: Manager) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for AgentRole { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for AgentRole { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for AgentRole { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ArchitectureComponent`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/architecture_component.schema.json\","] # [doc = "  \"title\": \"ArchitectureComponent\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"layer\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"ArchitectureComponent\""] # [doc = "        },"] # [doc = "        \"layer\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Frontend\","] # [doc = "            \"Backend\","] # [doc = "            \"Database\","] # [doc = "            \"Infrastructure\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct ArchitectureComponent { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : ArchitectureComponentKind , pub layer : ArchitectureComponentLayer , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & ArchitectureComponent > for ArchitectureComponent { fn from (value : & ArchitectureComponent) -> Self { value . clone () } } impl ArchitectureComponent { pub fn builder () -> builder :: ArchitectureComponent { Default :: default () } } # [doc = "`ArchitectureComponentKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ArchitectureComponent\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ArchitectureComponentKind { ArchitectureComponent , } impl :: std :: convert :: From < & Self > for ArchitectureComponentKind { fn from (value : & ArchitectureComponentKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ArchitectureComponentKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ArchitectureComponent => f . write_str ("ArchitectureComponent") , } } } impl :: std :: str :: FromStr for ArchitectureComponentKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ArchitectureComponent" => Ok (Self :: ArchitectureComponent) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ArchitectureComponentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ArchitectureComponentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ArchitectureComponentKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ArchitectureComponentLayer`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Frontend\","] # [doc = "    \"Backend\","] # [doc = "    \"Database\","] # [doc = "    \"Infrastructure\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ArchitectureComponentLayer { Frontend , Backend , Database , Infrastructure , } impl :: std :: convert :: From < & Self > for ArchitectureComponentLayer { fn from (value : & ArchitectureComponentLayer) -> Self { value . clone () } } impl :: std :: fmt :: Display for ArchitectureComponentLayer { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Frontend => f . write_str ("Frontend") , Self :: Backend => f . write_str ("Backend") , Self :: Database => f . write_str ("Database") , Self :: Infrastructure => f . write_str ("Infrastructure") , } } } impl :: std :: str :: FromStr for ArchitectureComponentLayer { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Frontend" => Ok (Self :: Frontend) , "Backend" => Ok (Self :: Backend) , "Database" => Ok (Self :: Database) , "Infrastructure" => Ok (Self :: Infrastructure) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ArchitectureComponentLayer { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ArchitectureComponentLayer { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ArchitectureComponentLayer { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A fundamental structural organization schema (e.g., MVC, Microservices)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/architecture_pattern.schema.json\","] # [doc = "  \"title\": \"ArchitecturePattern\","] # [doc = "  \"description\": \"A fundamental structural organization schema (e.g., MVC, Microservices).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"type\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"ArchitecturePattern\""] # [doc = "        },"] # [doc = "        \"principles\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"structure_diagram\": {"] # [doc = "          \"description\": \"Mermaid or text diagram of the pattern structure.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Monolith\","] # [doc = "            \"Microservices\","] # [doc = "            \"Event-Driven\","] # [doc = "            \"Layered\","] # [doc = "            \"Hexagonal\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct ArchitecturePattern { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : ArchitecturePatternKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub principles : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Mermaid or text diagram of the pattern structure."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub structure_diagram : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (rename = "type")] pub type_ : ArchitecturePatternType , } impl :: std :: convert :: From < & ArchitecturePattern > for ArchitecturePattern { fn from (value : & ArchitecturePattern) -> Self { value . clone () } } impl ArchitecturePattern { pub fn builder () -> builder :: ArchitecturePattern { Default :: default () } } # [doc = "`ArchitecturePatternKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ArchitecturePattern\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ArchitecturePatternKind { ArchitecturePattern , } impl :: std :: convert :: From < & Self > for ArchitecturePatternKind { fn from (value : & ArchitecturePatternKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ArchitecturePatternKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ArchitecturePattern => f . write_str ("ArchitecturePattern") , } } } impl :: std :: str :: FromStr for ArchitecturePatternKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ArchitecturePattern" => Ok (Self :: ArchitecturePattern) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ArchitecturePatternKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ArchitecturePatternKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ArchitecturePatternKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ArchitecturePatternType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Monolith\","] # [doc = "    \"Microservices\","] # [doc = "    \"Event-Driven\","] # [doc = "    \"Layered\","] # [doc = "    \"Hexagonal\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ArchitecturePatternType { Monolith , Microservices , # [serde (rename = "Event-Driven")] EventDriven , Layered , Hexagonal , } impl :: std :: convert :: From < & Self > for ArchitecturePatternType { fn from (value : & ArchitecturePatternType) -> Self { value . clone () } } impl :: std :: fmt :: Display for ArchitecturePatternType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Monolith => f . write_str ("Monolith") , Self :: Microservices => f . write_str ("Microservices") , Self :: EventDriven => f . write_str ("Event-Driven") , Self :: Layered => f . write_str ("Layered") , Self :: Hexagonal => f . write_str ("Hexagonal") , } } } impl :: std :: str :: FromStr for ArchitecturePatternType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Monolith" => Ok (Self :: Monolith) , "Microservices" => Ok (Self :: Microservices) , "Event-Driven" => Ok (Self :: EventDriven) , "Layered" => Ok (Self :: Layered) , "Hexagonal" => Ok (Self :: Hexagonal) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ArchitecturePatternType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ArchitecturePatternType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ArchitecturePatternType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A formal proposal to modify any artifact (SWEBOK: Configuration Control)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/change_request.schema.json\","] # [doc = "  \"title\": \"ChangeRequest\","] # [doc = "  \"description\": \"A formal proposal to modify any artifact (SWEBOK: Configuration Control).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"status\","] # [doc = "        \"target_entity_id\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"ChangeRequest\""] # [doc = "        },"] # [doc = "        \"reason\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"status\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Proposed\","] # [doc = "            \"Approved\","] # [doc = "            \"Rejected\","] # [doc = "            \"Implemented\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"target_entity_id\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"uuid\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct ChangeRequest { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : ChangeRequestKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub reason : :: std :: option :: Option < :: std :: string :: String > , pub status : ChangeRequestStatus , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , pub target_entity_id : :: uuid :: Uuid , } impl :: std :: convert :: From < & ChangeRequest > for ChangeRequest { fn from (value : & ChangeRequest) -> Self { value . clone () } } impl ChangeRequest { pub fn builder () -> builder :: ChangeRequest { Default :: default () } } # [doc = "`ChangeRequestKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ChangeRequest\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ChangeRequestKind { ChangeRequest , } impl :: std :: convert :: From < & Self > for ChangeRequestKind { fn from (value : & ChangeRequestKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ChangeRequestKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ChangeRequest => f . write_str ("ChangeRequest") , } } } impl :: std :: str :: FromStr for ChangeRequestKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ChangeRequest" => Ok (Self :: ChangeRequest) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ChangeRequestKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ChangeRequestKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ChangeRequestKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ChangeRequestStatus`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Proposed\","] # [doc = "    \"Approved\","] # [doc = "    \"Rejected\","] # [doc = "    \"Implemented\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ChangeRequestStatus { Proposed , Approved , Rejected , Implemented , } impl :: std :: convert :: From < & Self > for ChangeRequestStatus { fn from (value : & ChangeRequestStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for ChangeRequestStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Proposed => f . write_str ("Proposed") , Self :: Approved => f . write_str ("Approved") , Self :: Rejected => f . write_str ("Rejected") , Self :: Implemented => f . write_str ("Implemented") , } } } impl :: std :: str :: FromStr for ChangeRequestStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Proposed" => Ok (Self :: Proposed) , "Approved" => Ok (Self :: Approved) , "Rejected" => Ok (Self :: Rejected) , "Implemented" => Ok (Self :: Implemented) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ChangeRequestStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ChangeRequestStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ChangeRequestStatus { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`Command`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/command.schema.json\","] # [doc = "  \"title\": \"Command\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"executable\","] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"arguments\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"executable\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Command\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Command { # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub arguments : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub executable : :: std :: string :: String , pub id : :: uuid :: Uuid , pub kind : CommandKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Command > for Command { fn from (value : & Command) -> Self { value . clone () } } impl Command { pub fn builder () -> builder :: Command { Default :: default () } } # [doc = "`CommandKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Command\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum CommandKind { Command , } impl :: std :: convert :: From < & Self > for CommandKind { fn from (value : & CommandKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for CommandKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Command => f . write_str ("Command") , } } } impl :: std :: str :: FromStr for CommandKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Command" => Ok (Self :: Command) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for CommandKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for CommandKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for CommandKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`DataModel`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/data_model.schema.json\","] # [doc = "  \"title\": \"DataModel\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"schema_definition\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"DataModel\""] # [doc = "        },"] # [doc = "        \"schema_definition\": {"] # [doc = "          \"description\": \"SQL or JSON schema content\","] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DataModel { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : DataModelKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "SQL or JSON schema content"] pub schema_definition : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & DataModel > for DataModel { fn from (value : & DataModel) -> Self { value . clone () } } impl DataModel { pub fn builder () -> builder :: DataModel { Default :: default () } } # [doc = "`DataModelKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"DataModel\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum DataModelKind { DataModel , } impl :: std :: convert :: From < & Self > for DataModelKind { fn from (value : & DataModelKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for DataModelKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: DataModel => f . write_str ("DataModel") , } } } impl :: std :: str :: FromStr for DataModelKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "DataModel" => Ok (Self :: DataModel) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for DataModelKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for DataModelKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for DataModelKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Technical design description (SDD) for a feature (SWEBOK: Software Design)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/design_spec.schema.json\","] # [doc = "  \"title\": \"DesignSpec\","] # [doc = "  \"description\": \"Technical design description (SDD) for a feature (SWEBOK: Software Design).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"data_spec\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"DesignSpec\""] # [doc = "        },"] # [doc = "        \"logic_spec\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"ui_spec\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"verification_plan\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DesignSpec { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub data_spec : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : DesignSpecKind , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub logic_spec : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub ui_spec : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub verification_plan : :: std :: option :: Option < :: std :: string :: String > , } impl :: std :: convert :: From < & DesignSpec > for DesignSpec { fn from (value : & DesignSpec) -> Self { value . clone () } } impl DesignSpec { pub fn builder () -> builder :: DesignSpec { Default :: default () } } # [doc = "`DesignSpecKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"DesignSpec\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum DesignSpecKind { DesignSpec , } impl :: std :: convert :: From < & Self > for DesignSpecKind { fn from (value : & DesignSpecKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for DesignSpecKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: DesignSpec => f . write_str ("DesignSpec") , } } } impl :: std :: str :: FromStr for DesignSpecKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "DesignSpec" => Ok (Self :: DesignSpec) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for DesignSpecKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for DesignSpecKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for DesignSpecKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A data object in the domain model (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/domain_entity.schema.json\","] # [doc = "  \"title\": \"DomainEntity\","] # [doc = "  \"description\": \"A data object in the domain model (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"attributes\","] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"attributes\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"name\","] # [doc = "              \"type\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"description\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"is_primary_key\": {"] # [doc = "                \"type\": \"boolean\""] # [doc = "              },"] # [doc = "              \"name\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"required\": {"] # [doc = "                \"type\": \"boolean\""] # [doc = "              },"] # [doc = "              \"type\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"DomainEntity\""] # [doc = "        },"] # [doc = "        \"relationships\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"relation_type\","] # [doc = "              \"target_entity\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"description\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"relation_type\": {"] # [doc = "                \"enum\": ["] # [doc = "                  \"OneToOne\","] # [doc = "                  \"OneToMany\","] # [doc = "                  \"ManyToOne\","] # [doc = "                  \"ManyToMany\""] # [doc = "                ]"] # [doc = "              },"] # [doc = "              \"target_entity\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DomainEntity { pub attributes : :: std :: vec :: Vec < DomainEntityAttributesItem > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : DomainEntityKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub relationships : :: std :: vec :: Vec < DomainEntityRelationshipsItem > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & DomainEntity > for DomainEntity { fn from (value : & DomainEntity) -> Self { value . clone () } } impl DomainEntity { pub fn builder () -> builder :: DomainEntity { Default :: default () } } # [doc = "`DomainEntityAttributesItem`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"name\","] # [doc = "    \"type\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"description\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"is_primary_key\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"required\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"type\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DomainEntityAttributesItem { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub is_primary_key : :: std :: option :: Option < bool > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub required : :: std :: option :: Option < bool > , # [serde (rename = "type")] pub type_ : :: std :: string :: String , } impl :: std :: convert :: From < & DomainEntityAttributesItem > for DomainEntityAttributesItem { fn from (value : & DomainEntityAttributesItem) -> Self { value . clone () } } impl DomainEntityAttributesItem { pub fn builder () -> builder :: DomainEntityAttributesItem { Default :: default () } } # [doc = "`DomainEntityKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"DomainEntity\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum DomainEntityKind { DomainEntity , } impl :: std :: convert :: From < & Self > for DomainEntityKind { fn from (value : & DomainEntityKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for DomainEntityKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: DomainEntity => f . write_str ("DomainEntity") , } } } impl :: std :: str :: FromStr for DomainEntityKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "DomainEntity" => Ok (Self :: DomainEntity) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for DomainEntityKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for DomainEntityKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for DomainEntityKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`DomainEntityRelationshipsItem`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"relation_type\","] # [doc = "    \"target_entity\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"description\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"relation_type\": {"] # [doc = "      \"enum\": ["] # [doc = "        \"OneToOne\","] # [doc = "        \"OneToMany\","] # [doc = "        \"ManyToOne\","] # [doc = "        \"ManyToMany\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"target_entity\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DomainEntityRelationshipsItem { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub relation_type : DomainEntityRelationshipsItemRelationType , pub target_entity : :: std :: string :: String , } impl :: std :: convert :: From < & DomainEntityRelationshipsItem > for DomainEntityRelationshipsItem { fn from (value : & DomainEntityRelationshipsItem) -> Self { value . clone () } } impl DomainEntityRelationshipsItem { pub fn builder () -> builder :: DomainEntityRelationshipsItem { Default :: default () } } # [doc = "`DomainEntityRelationshipsItemRelationType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"OneToOne\","] # [doc = "    \"OneToMany\","] # [doc = "    \"ManyToOne\","] # [doc = "    \"ManyToMany\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum DomainEntityRelationshipsItemRelationType { OneToOne , OneToMany , ManyToOne , ManyToMany , } impl :: std :: convert :: From < & Self > for DomainEntityRelationshipsItemRelationType { fn from (value : & DomainEntityRelationshipsItemRelationType) -> Self { value . clone () } } impl :: std :: fmt :: Display for DomainEntityRelationshipsItemRelationType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: OneToOne => f . write_str ("OneToOne") , Self :: OneToMany => f . write_str ("OneToMany") , Self :: ManyToOne => f . write_str ("ManyToOne") , Self :: ManyToMany => f . write_str ("ManyToMany") , } } } impl :: std :: str :: FromStr for DomainEntityRelationshipsItemRelationType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "OneToOne" => Ok (Self :: OneToOne) , "OneToMany" => Ok (Self :: OneToMany) , "ManyToOne" => Ok (Self :: ManyToOne) , "ManyToMany" => Ok (Self :: ManyToMany) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for DomainEntityRelationshipsItemRelationType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for DomainEntityRelationshipsItemRelationType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for DomainEntityRelationshipsItemRelationType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`EntityMetadata`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"kind\","] # [doc = "    \"name\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"description\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"kind\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"metadata\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"additionalProperties\": true"] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"synonyms\": {"] # [doc = "      \"description\": \"Alternative names for this entity (e.g., Feature -> Epic).\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"tags\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct EntityMetadata { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : :: std :: string :: String , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & EntityMetadata > for EntityMetadata { fn from (value : & EntityMetadata) -> Self { value . clone () } } impl EntityMetadata { pub fn builder () -> builder :: EntityMetadata { Default :: default () } } # [doc = "The operational context (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/environment.schema.json\","] # [doc = "  \"title\": \"Environment\","] # [doc = "  \"description\": \"The operational context (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"type\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"container_image\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"env_variables\": {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"additionalProperties\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Environment\""] # [doc = "        },"] # [doc = "        \"os\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"secrets\": {"] # [doc = "          \"description\": \"List of secret names required (values not stored here).\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"tools\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Development\","] # [doc = "            \"Tests\","] # [doc = "            \"Staging\","] # [doc = "            \"Production\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Environment { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub container_image : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = ":: std :: collections :: HashMap::is_empty")] pub env_variables : :: std :: collections :: HashMap < :: std :: string :: String , :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : EnvironmentKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub os : :: std :: option :: Option < :: std :: string :: String > , # [doc = "List of secret names required (values not stored here)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub secrets : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tools : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (rename = "type")] pub type_ : EnvironmentType , } impl :: std :: convert :: From < & Environment > for Environment { fn from (value : & Environment) -> Self { value . clone () } } impl Environment { pub fn builder () -> builder :: Environment { Default :: default () } } # [doc = "`EnvironmentKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Environment\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum EnvironmentKind { Environment , } impl :: std :: convert :: From < & Self > for EnvironmentKind { fn from (value : & EnvironmentKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for EnvironmentKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Environment => f . write_str ("Environment") , } } } impl :: std :: str :: FromStr for EnvironmentKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Environment" => Ok (Self :: Environment) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for EnvironmentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for EnvironmentKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for EnvironmentKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`EnvironmentType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Development\","] # [doc = "    \"Tests\","] # [doc = "    \"Staging\","] # [doc = "    \"Production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum EnvironmentType { Development , Tests , Staging , Production , } impl :: std :: convert :: From < & Self > for EnvironmentType { fn from (value : & EnvironmentType) -> Self { value . clone () } } impl :: std :: fmt :: Display for EnvironmentType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Development => f . write_str ("Development") , Self :: Tests => f . write_str ("Tests") , Self :: Staging => f . write_str ("Staging") , Self :: Production => f . write_str ("Production") , } } } impl :: std :: str :: FromStr for EnvironmentType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Development" => Ok (Self :: Development) , "Tests" => Ok (Self :: Tests) , "Staging" => Ok (Self :: Staging) , "Production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for EnvironmentType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for EnvironmentType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for EnvironmentType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A high-level functional capability or 'Epic'."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/feature.schema.json\","] # [doc = "  \"title\": \"Feature\","] # [doc = "  \"description\": \"A high-level functional capability or 'Epic'.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"business_value\","] # [doc = "        \"kind\","] # [doc = "        \"priority\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"business_value\": {"] # [doc = "          \"description\": \"Why this feature provides value to the business/user.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Feature\""] # [doc = "        },"] # [doc = "        \"priority\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Critical\","] # [doc = "            \"High\","] # [doc = "            \"Medium\","] # [doc = "            \"Low\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"status\": {"] # [doc = "          \"default\": \"Proposed\","] # [doc = "          \"enum\": ["] # [doc = "            \"Proposed\","] # [doc = "            \"In Progress\","] # [doc = "            \"Completed\","] # [doc = "            \"Deferred\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Feature { # [doc = "Why this feature provides value to the business/user."] pub business_value : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : FeatureKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , pub priority : FeaturePriority , # [serde (default = "defaults::feature_status")] pub status : FeatureStatus , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Feature > for Feature { fn from (value : & Feature) -> Self { value . clone () } } impl Feature { pub fn builder () -> builder :: Feature { Default :: default () } } # [doc = "`FeatureKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Feature\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum FeatureKind { Feature , } impl :: std :: convert :: From < & Self > for FeatureKind { fn from (value : & FeatureKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for FeatureKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Feature => f . write_str ("Feature") , } } } impl :: std :: str :: FromStr for FeatureKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Feature" => Ok (Self :: Feature) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for FeatureKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for FeatureKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for FeatureKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`FeaturePriority`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Critical\","] # [doc = "    \"High\","] # [doc = "    \"Medium\","] # [doc = "    \"Low\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum FeaturePriority { Critical , High , Medium , Low , } impl :: std :: convert :: From < & Self > for FeaturePriority { fn from (value : & FeaturePriority) -> Self { value . clone () } } impl :: std :: fmt :: Display for FeaturePriority { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Critical => f . write_str ("Critical") , Self :: High => f . write_str ("High") , Self :: Medium => f . write_str ("Medium") , Self :: Low => f . write_str ("Low") , } } } impl :: std :: str :: FromStr for FeaturePriority { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Critical" => Ok (Self :: Critical) , "High" => Ok (Self :: High) , "Medium" => Ok (Self :: Medium) , "Low" => Ok (Self :: Low) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for FeaturePriority { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for FeaturePriority { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for FeaturePriority { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`FeatureStatus`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"Proposed\","] # [doc = "  \"enum\": ["] # [doc = "    \"Proposed\","] # [doc = "    \"In Progress\","] # [doc = "    \"Completed\","] # [doc = "    \"Deferred\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum FeatureStatus { Proposed , # [serde (rename = "In Progress")] InProgress , Completed , Deferred , } impl :: std :: convert :: From < & Self > for FeatureStatus { fn from (value : & FeatureStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for FeatureStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Proposed => f . write_str ("Proposed") , Self :: InProgress => f . write_str ("In Progress") , Self :: Completed => f . write_str ("Completed") , Self :: Deferred => f . write_str ("Deferred") , } } } impl :: std :: str :: FromStr for FeatureStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Proposed" => Ok (Self :: Proposed) , "In Progress" => Ok (Self :: InProgress) , "Completed" => Ok (Self :: Completed) , "Deferred" => Ok (Self :: Deferred) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for FeatureStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for FeatureStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for FeatureStatus { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: default :: Default for FeatureStatus { fn default () -> Self { FeatureStatus :: Proposed } } # [doc = "`FileSystemNode`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"name\","] # [doc = "    \"type\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"children\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"$ref\": \"#/definitions/FileSystemNode\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"description\": {"] # [doc = "      \"description\": \"Purpose of this node\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"description\": \"Name of directory or file node\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"type\": {"] # [doc = "      \"enum\": ["] # [doc = "        \"Directory\","] # [doc = "        \"File\","] # [doc = "        \"Module\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct FileSystemNode { # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub children : :: std :: vec :: Vec < FileSystemNode > , # [doc = "Purpose of this node"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Name of directory or file node"] pub name : :: std :: string :: String , # [serde (rename = "type")] pub type_ : FileSystemNodeType , } impl :: std :: convert :: From < & FileSystemNode > for FileSystemNode { fn from (value : & FileSystemNode) -> Self { value . clone () } } impl FileSystemNode { pub fn builder () -> builder :: FileSystemNode { Default :: default () } } # [doc = "`FileSystemNodeType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Directory\","] # [doc = "    \"File\","] # [doc = "    \"Module\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum FileSystemNodeType { Directory , File , Module , } impl :: std :: convert :: From < & Self > for FileSystemNodeType { fn from (value : & FileSystemNodeType) -> Self { value . clone () } } impl :: std :: fmt :: Display for FileSystemNodeType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Directory => f . write_str ("Directory") , Self :: File => f . write_str ("File") , Self :: Module => f . write_str ("Module") , } } } impl :: std :: str :: FromStr for FileSystemNodeType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Directory" => Ok (Self :: Directory) , "File" => Ok (Self :: File) , "Module" => Ok (Self :: Module) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for FileSystemNodeType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for FileSystemNodeType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for FileSystemNodeType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "An insight or error captured during execution (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/observation.schema.json\","] # [doc = "  \"title\": \"Observation\","] # [doc = "  \"description\": \"An insight or error captured during execution (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"insight\","] # [doc = "        \"kind\","] # [doc = "        \"severity\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"artifact_id\": {"] # [doc = "          \"description\": \"ID of the artifact related to this observation (Risk, TestResult, etc.)\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"context\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"insight\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Observation\""] # [doc = "        },"] # [doc = "        \"observed_at\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"date-time\""] # [doc = "        },"] # [doc = "        \"recommendation\": {"] # [doc = "          \"description\": \"Suggested action to address the observation.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"severity\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Info\","] # [doc = "            \"Warning\","] # [doc = "            \"Error\","] # [doc = "            \"Critical\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Observation { # [doc = "ID of the artifact related to this observation (Risk, TestResult, etc.)"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub artifact_id : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub context : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub insight : :: std :: string :: String , pub kind : ObservationKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub observed_at : :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , # [doc = "Suggested action to address the observation."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub recommendation : :: std :: option :: Option < :: std :: string :: String > , pub severity : ObservationSeverity , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Observation > for Observation { fn from (value : & Observation) -> Self { value . clone () } } impl Observation { pub fn builder () -> builder :: Observation { Default :: default () } } # [doc = "`ObservationKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Observation\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ObservationKind { Observation , } impl :: std :: convert :: From < & Self > for ObservationKind { fn from (value : & ObservationKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ObservationKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Observation => f . write_str ("Observation") , } } } impl :: std :: str :: FromStr for ObservationKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Observation" => Ok (Self :: Observation) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ObservationKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ObservationKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ObservationKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ObservationSeverity`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Info\","] # [doc = "    \"Warning\","] # [doc = "    \"Error\","] # [doc = "    \"Critical\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ObservationSeverity { Info , Warning , Error , Critical , } impl :: std :: convert :: From < & Self > for ObservationSeverity { fn from (value : & ObservationSeverity) -> Self { value . clone () } } impl :: std :: fmt :: Display for ObservationSeverity { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Info => f . write_str ("Info") , Self :: Warning => f . write_str ("Warning") , Self :: Error => f . write_str ("Error") , Self :: Critical => f . write_str ("Critical") , } } } impl :: std :: str :: FromStr for ObservationSeverity { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Info" => Ok (Self :: Info) , "Warning" => Ok (Self :: Warning) , "Error" => Ok (Self :: Error) , "Critical" => Ok (Self :: Critical) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ObservationSeverity { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ObservationSeverity { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ObservationSeverity { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A representation of a user role or stakeholder (e.g., 'Admin', 'Guest')."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/persona.schema.json\","] # [doc = "  \"title\": \"Persona\","] # [doc = "  \"description\": \"A representation of a user role or stakeholder (e.g., 'Admin', 'Guest').\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"role\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Persona\""] # [doc = "        },"] # [doc = "        \"responsibilities\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"role\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Persona { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : PersonaKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub responsibilities : :: std :: vec :: Vec < :: std :: string :: String > , pub role : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Persona > for Persona { fn from (value : & Persona) -> Self { value . clone () } } impl Persona { pub fn builder () -> builder :: Persona { Default :: default () } } # [doc = "`PersonaKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Persona\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PersonaKind { Persona , } impl :: std :: convert :: From < & Self > for PersonaKind { fn from (value : & PersonaKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for PersonaKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Persona => f . write_str ("Persona") , } } } impl :: std :: str :: FromStr for PersonaKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Persona" => Ok (Self :: Persona) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for PersonaKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for PersonaKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for PersonaKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A set of structured tasks to implement a specification."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/plan.schema.json\","] # [doc = "  \"title\": \"Plan\","] # [doc = "  \"description\": \"A set of structured tasks to implement a specification.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"tasks\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Plan\""] # [doc = "        },"] # [doc = "        \"tasks\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"description\","] # [doc = "              \"id\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"dependencies\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\""] # [doc = "                }"] # [doc = "              },"] # [doc = "              \"description\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"estimated_duration\": {"] # [doc = "                \"description\": \"e.g., '2h', '1d'\","] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"id\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Plan { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : PlanKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , pub tasks : :: std :: vec :: Vec < PlanTasksItem > , } impl :: std :: convert :: From < & Plan > for Plan { fn from (value : & Plan) -> Self { value . clone () } } impl Plan { pub fn builder () -> builder :: Plan { Default :: default () } } # [doc = "`PlanKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Plan\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PlanKind { Plan , } impl :: std :: convert :: From < & Self > for PlanKind { fn from (value : & PlanKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for PlanKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Plan => f . write_str ("Plan") , } } } impl :: std :: str :: FromStr for PlanKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Plan" => Ok (Self :: Plan) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for PlanKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for PlanKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for PlanKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`PlanTasksItem`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"description\","] # [doc = "    \"id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"dependencies\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"description\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"estimated_duration\": {"] # [doc = "      \"description\": \"e.g., '2h', '1d'\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PlanTasksItem { # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub dependencies : :: std :: vec :: Vec < :: std :: string :: String > , pub description : :: std :: string :: String , # [doc = "e.g., '2h', '1d'"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub estimated_duration : :: std :: option :: Option < :: std :: string :: String > , pub id : :: std :: string :: String , } impl :: std :: convert :: From < & PlanTasksItem > for PlanTasksItem { fn from (value : & PlanTasksItem) -> Self { value . clone () } } impl PlanTasksItem { pub fn builder () -> builder :: PlanTasksItem { Default :: default () } } # [doc = "The physical directory layout and logical module organization (SWEBOK: Software Construction)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/project_structure.schema.json\","] # [doc = "  \"title\": \"ProjectStructure\","] # [doc = "  \"description\": \"The physical directory layout and logical module organization (SWEBOK: Software Construction).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"layout\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"conventions\": {"] # [doc = "          \"description\": \"Language-specific rules (e.g., 'Rust: src/main.rs is entry')\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"ProjectStructure\""] # [doc = "        },"] # [doc = "        \"layout\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"$ref\": \"#/definitions/FileSystemNode\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"root_path\": {"] # [doc = "          \"description\": \"Absolute or relative root (e.g., './crate-name')\","] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct ProjectStructure { # [doc = "Language-specific rules (e.g., 'Rust: src/main.rs is entry')"] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub conventions : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : ProjectStructureKind , pub layout : :: std :: vec :: Vec < FileSystemNode > , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Absolute or relative root (e.g., './crate-name')"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub root_path : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & ProjectStructure > for ProjectStructure { fn from (value : & ProjectStructure) -> Self { value . clone () } } impl ProjectStructure { pub fn builder () -> builder :: ProjectStructure { Default :: default () } } # [doc = "`ProjectStructureKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ProjectStructure\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ProjectStructureKind { ProjectStructure , } impl :: std :: convert :: From < & Self > for ProjectStructureKind { fn from (value : & ProjectStructureKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ProjectStructureKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ProjectStructure => f . write_str ("ProjectStructure") , } } } impl :: std :: str :: FromStr for ProjectStructureKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "ProjectStructure" => Ok (Self :: ProjectStructure) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ProjectStructureKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ProjectStructureKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ProjectStructureKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "An atomic unit of functionality or constraint (SWEBOK: Software Requirements)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/requirement.schema.json\","] # [doc = "  \"title\": \"Requirement\","] # [doc = "  \"description\": \"An atomic unit of functionality or constraint (SWEBOK: Software Requirements).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"acceptance_criteria\","] # [doc = "        \"kind\","] # [doc = "        \"req_type\","] # [doc = "        \"user_story\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"acceptance_criteria\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"minItems\": 1"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Requirement\""] # [doc = "        },"] # [doc = "        \"priority\": {"] # [doc = "          \"description\": \"MoSCoW prioritization.\","] # [doc = "          \"enum\": ["] # [doc = "            \"Must Have\","] # [doc = "            \"Should Have\","] # [doc = "            \"Could Have\","] # [doc = "            \"Won't Have\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"req_type\": {"] # [doc = "          \"description\": \"Classifies the requirement type (FR vs NFR).\","] # [doc = "          \"enum\": ["] # [doc = "            \"Functional\","] # [doc = "            \"Non-Functional\","] # [doc = "            \"Constraint\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"user_story\": {"] # [doc = "          \"description\": \"As a <role>, I want <feature>, so that <benefit>.\","] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Requirement { pub acceptance_criteria : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : RequirementKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "MoSCoW prioritization."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub priority : :: std :: option :: Option < RequirementPriority > , # [doc = "Classifies the requirement type (FR vs NFR)."] pub req_type : RequirementReqType , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "As a <role>, I want <feature>, so that <benefit>."] pub user_story : :: std :: string :: String , } impl :: std :: convert :: From < & Requirement > for Requirement { fn from (value : & Requirement) -> Self { value . clone () } } impl Requirement { pub fn builder () -> builder :: Requirement { Default :: default () } } # [doc = "`RequirementKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Requirement\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RequirementKind { Requirement , } impl :: std :: convert :: From < & Self > for RequirementKind { fn from (value : & RequirementKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for RequirementKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Requirement => f . write_str ("Requirement") , } } } impl :: std :: str :: FromStr for RequirementKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Requirement" => Ok (Self :: Requirement) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RequirementKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RequirementKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RequirementKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "MoSCoW prioritization."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"MoSCoW prioritization.\","] # [doc = "  \"enum\": ["] # [doc = "    \"Must Have\","] # [doc = "    \"Should Have\","] # [doc = "    \"Could Have\","] # [doc = "    \"Won't Have\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RequirementPriority { # [serde (rename = "Must Have")] MustHave , # [serde (rename = "Should Have")] ShouldHave , # [serde (rename = "Could Have")] CouldHave , # [serde (rename = "Won't Have")] WontHave , } impl :: std :: convert :: From < & Self > for RequirementPriority { fn from (value : & RequirementPriority) -> Self { value . clone () } } impl :: std :: fmt :: Display for RequirementPriority { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: MustHave => f . write_str ("Must Have") , Self :: ShouldHave => f . write_str ("Should Have") , Self :: CouldHave => f . write_str ("Could Have") , Self :: WontHave => f . write_str ("Won't Have") , } } } impl :: std :: str :: FromStr for RequirementPriority { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Must Have" => Ok (Self :: MustHave) , "Should Have" => Ok (Self :: ShouldHave) , "Could Have" => Ok (Self :: CouldHave) , "Won't Have" => Ok (Self :: WontHave) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RequirementPriority { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RequirementPriority { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RequirementPriority { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Classifies the requirement type (FR vs NFR)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Classifies the requirement type (FR vs NFR).\","] # [doc = "  \"enum\": ["] # [doc = "    \"Functional\","] # [doc = "    \"Non-Functional\","] # [doc = "    \"Constraint\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RequirementReqType { Functional , # [serde (rename = "Non-Functional")] NonFunctional , Constraint , } impl :: std :: convert :: From < & Self > for RequirementReqType { fn from (value : & RequirementReqType) -> Self { value . clone () } } impl :: std :: fmt :: Display for RequirementReqType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Functional => f . write_str ("Functional") , Self :: NonFunctional => f . write_str ("Non-Functional") , Self :: Constraint => f . write_str ("Constraint") , } } } impl :: std :: str :: FromStr for RequirementReqType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Functional" => Ok (Self :: Functional) , "Non-Functional" => Ok (Self :: NonFunctional) , "Constraint" => Ok (Self :: Constraint) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RequirementReqType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RequirementReqType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RequirementReqType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A potential future event that may negatively impact the project (SWEBOK: Risk Management)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/risk.schema.json\","] # [doc = "  \"title\": \"Risk\","] # [doc = "  \"description\": \"A potential future event that may negatively impact the project (SWEBOK: Risk Management).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"impact\","] # [doc = "        \"kind\","] # [doc = "        \"mitigation_plan\","] # [doc = "        \"probability\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"impact\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Critical\","] # [doc = "            \"Major\","] # [doc = "            \"Minor\","] # [doc = "            \"Negligible\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Risk\""] # [doc = "        },"] # [doc = "        \"mitigation_plan\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"probability\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"High\","] # [doc = "            \"Medium\","] # [doc = "            \"Low\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Risk { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub impact : RiskImpact , pub kind : RiskKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub mitigation_plan : :: std :: string :: String , pub name : :: std :: string :: String , pub probability : RiskProbability , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Risk > for Risk { fn from (value : & Risk) -> Self { value . clone () } } impl Risk { pub fn builder () -> builder :: Risk { Default :: default () } } # [doc = "`RiskImpact`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Critical\","] # [doc = "    \"Major\","] # [doc = "    \"Minor\","] # [doc = "    \"Negligible\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RiskImpact { Critical , Major , Minor , Negligible , } impl :: std :: convert :: From < & Self > for RiskImpact { fn from (value : & RiskImpact) -> Self { value . clone () } } impl :: std :: fmt :: Display for RiskImpact { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Critical => f . write_str ("Critical") , Self :: Major => f . write_str ("Major") , Self :: Minor => f . write_str ("Minor") , Self :: Negligible => f . write_str ("Negligible") , } } } impl :: std :: str :: FromStr for RiskImpact { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Critical" => Ok (Self :: Critical) , "Major" => Ok (Self :: Major) , "Minor" => Ok (Self :: Minor) , "Negligible" => Ok (Self :: Negligible) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RiskImpact { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RiskImpact { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RiskImpact { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`RiskKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Risk\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RiskKind { Risk , } impl :: std :: convert :: From < & Self > for RiskKind { fn from (value : & RiskKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for RiskKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Risk => f . write_str ("Risk") , } } } impl :: std :: str :: FromStr for RiskKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Risk" => Ok (Self :: Risk) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RiskKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RiskKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RiskKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`RiskProbability`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"High\","] # [doc = "    \"Medium\","] # [doc = "    \"Low\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum RiskProbability { High , Medium , Low , } impl :: std :: convert :: From < & Self > for RiskProbability { fn from (value : & RiskProbability) -> Self { value . clone () } } impl :: std :: fmt :: Display for RiskProbability { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: High => f . write_str ("High") , Self :: Medium => f . write_str ("Medium") , Self :: Low => f . write_str ("Low") , } } } impl :: std :: str :: FromStr for RiskProbability { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "High" => Ok (Self :: High) , "Medium" => Ok (Self :: Medium) , "Low" => Ok (Self :: Low) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for RiskProbability { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for RiskProbability { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for RiskProbability { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "The root container for the entire software engineering project."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/software_application.schema.json\","] # [doc = "  \"title\": \"SoftwareApplication\","] # [doc = "  \"description\": \"The root container for the entire software engineering project.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"SoftwareApplication\""] # [doc = "        },"] # [doc = "        \"work_dir\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct SoftwareApplication { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : SoftwareApplicationKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub work_dir : :: std :: option :: Option < :: std :: string :: String > , } impl :: std :: convert :: From < & SoftwareApplication > for SoftwareApplication { fn from (value : & SoftwareApplication) -> Self { value . clone () } } impl SoftwareApplication { pub fn builder () -> builder :: SoftwareApplication { Default :: default () } } # [doc = "`SoftwareApplicationKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"SoftwareApplication\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum SoftwareApplicationKind { SoftwareApplication , } impl :: std :: convert :: From < & Self > for SoftwareApplicationKind { fn from (value : & SoftwareApplicationKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for SoftwareApplicationKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: SoftwareApplication => f . write_str ("SoftwareApplication") , } } } impl :: std :: str :: FromStr for SoftwareApplicationKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "SoftwareApplication" => Ok (Self :: SoftwareApplication) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for SoftwareApplicationKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for SoftwareApplicationKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for SoftwareApplicationKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Validation schemas for the Autonomous Coding Loop entities."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json\","] # [doc = "  \"title\": \"Software Engineering Taxonomy (Complete + Agents)\","] # [doc = "  \"description\": \"Validation schemas for the Autonomous Coding Loop entities.\","] # [doc = "  \"type\": \"object\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (transparent)] pub struct SoftwareEngineeringTaxonomyCompleteAgents (pub :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value >) ; impl :: std :: ops :: Deref for SoftwareEngineeringTaxonomyCompleteAgents { type Target = :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > ; fn deref (& self) -> & :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > { & self . 0 } } impl :: std :: convert :: From < SoftwareEngineeringTaxonomyCompleteAgents > for :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > { fn from (value : SoftwareEngineeringTaxonomyCompleteAgents) -> Self { value . 0 } } impl :: std :: convert :: From < & SoftwareEngineeringTaxonomyCompleteAgents > for SoftwareEngineeringTaxonomyCompleteAgents { fn from (value : & SoftwareEngineeringTaxonomyCompleteAgents) -> Self { value . clone () } } impl :: std :: convert :: From < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > for SoftwareEngineeringTaxonomyCompleteAgents { fn from (value : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value >) -> Self { Self (value) } } # [doc = "A file containing source code (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/source_file.schema.json\","] # [doc = "  \"title\": \"SourceFile\","] # [doc = "  \"description\": \"A file containing source code (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"language\","] # [doc = "        \"path\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"checksum\": {"] # [doc = "          \"description\": \"SHA-256 hash for integrity verification\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"content\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"SourceFile\""] # [doc = "        },"] # [doc = "        \"language\": {"] # [doc = "          \"description\": \"e.g., Rust, Python\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"language_version\": {"] # [doc = "          \"description\": \"e.g., 2021, 3.10\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"path\": {"] # [doc = "          \"description\": \"Relative path from project root\","] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct SourceFile { # [doc = "SHA-256 hash for integrity verification"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub checksum : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub content : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : SourceFileKind , # [doc = "e.g., Rust, Python"] pub language : :: std :: string :: String , # [doc = "e.g., 2021, 3.10"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub language_version : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Relative path from project root"] pub path : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & SourceFile > for SourceFile { fn from (value : & SourceFile) -> Self { value . clone () } } impl SourceFile { pub fn builder () -> builder :: SourceFile { Default :: default () } } # [doc = "`SourceFileKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"SourceFile\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum SourceFileKind { SourceFile , } impl :: std :: convert :: From < & Self > for SourceFileKind { fn from (value : & SourceFileKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for SourceFileKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: SourceFile => f . write_str ("SourceFile") , } } } impl :: std :: str :: FromStr for SourceFileKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "SourceFile" => Ok (Self :: SourceFile) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for SourceFileKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for SourceFileKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for SourceFileKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A rule or constraint that applies to the project."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/standard.schema.json\","] # [doc = "  \"title\": \"Standard\","] # [doc = "  \"description\": \"A rule or constraint that applies to the project.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"category\","] # [doc = "        \"kind\","] # [doc = "        \"rules\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"category\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Language\","] # [doc = "            \"Framework\","] # [doc = "            \"Style\","] # [doc = "            \"Testing\","] # [doc = "            \"Deployment\","] # [doc = "            \"Security\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"command_template\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"compliance_level\": {"] # [doc = "          \"default\": \"Mandatory\","] # [doc = "          \"enum\": ["] # [doc = "            \"Mandatory\","] # [doc = "            \"Recommended\","] # [doc = "            \"Optional\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"enforcement_tool\": {"] # [doc = "          \"description\": \"Tool used to enforce this (e.g., 'clippy', 'eslint')\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Standard\""] # [doc = "        },"] # [doc = "        \"rules\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Standard { pub category : StandardCategory , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub command_template : :: std :: option :: Option < :: std :: string :: String > , # [serde (default = "defaults::standard_compliance_level")] pub compliance_level : StandardComplianceLevel , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Tool used to enforce this (e.g., 'clippy', 'eslint')"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub enforcement_tool : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : StandardKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , pub rules : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & Standard > for Standard { fn from (value : & Standard) -> Self { value . clone () } } impl Standard { pub fn builder () -> builder :: Standard { Default :: default () } } # [doc = "`StandardCategory`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Language\","] # [doc = "    \"Framework\","] # [doc = "    \"Style\","] # [doc = "    \"Testing\","] # [doc = "    \"Deployment\","] # [doc = "    \"Security\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum StandardCategory { Language , Framework , Style , Testing , Deployment , Security , } impl :: std :: convert :: From < & Self > for StandardCategory { fn from (value : & StandardCategory) -> Self { value . clone () } } impl :: std :: fmt :: Display for StandardCategory { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Language => f . write_str ("Language") , Self :: Framework => f . write_str ("Framework") , Self :: Style => f . write_str ("Style") , Self :: Testing => f . write_str ("Testing") , Self :: Deployment => f . write_str ("Deployment") , Self :: Security => f . write_str ("Security") , } } } impl :: std :: str :: FromStr for StandardCategory { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Language" => Ok (Self :: Language) , "Framework" => Ok (Self :: Framework) , "Style" => Ok (Self :: Style) , "Testing" => Ok (Self :: Testing) , "Deployment" => Ok (Self :: Deployment) , "Security" => Ok (Self :: Security) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for StandardCategory { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for StandardCategory { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for StandardCategory { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`StandardComplianceLevel`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"Mandatory\","] # [doc = "  \"enum\": ["] # [doc = "    \"Mandatory\","] # [doc = "    \"Recommended\","] # [doc = "    \"Optional\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] #[derive(Default)]
2 ~ pub enum StandardComplianceLevel { #[default]
3 ~ Mandatory , Recommended , Optional , } impl :: std :: convert :: From < & Self > for StandardComplianceLevel { fn from (value : & StandardComplianceLevel) -> Self { value . clone () } } impl :: std :: fmt :: Display for StandardComplianceLevel { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Mandatory => f . write_str ("Mandatory") , Self :: Recommended => f . write_str ("Recommended") , Self :: Optional => f . write_str ("Optional") , } } } impl :: std :: str :: FromStr for StandardComplianceLevel { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Mandatory" => Ok (Self :: Mandatory) , "Recommended" => Ok (Self :: Recommended) , "Optional" => Ok (Self :: Optional) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for StandardComplianceLevel { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for StandardComplianceLevel { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for StandardComplianceLevel { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } }  # [doc = "`StandardKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Standard\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum StandardKind { Standard , } impl :: std :: convert :: From < & Self > for StandardKind { fn from (value : & StandardKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for StandardKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Standard => f . write_str ("Standard") , } } } impl :: std :: str :: FromStr for StandardKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Standard" => Ok (Self :: Standard) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for StandardKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for StandardKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for StandardKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A specific technology item chosen for the project (e.g., 'React', 'Tokio')."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/tech_stack.schema.json\","] # [doc = "  \"title\": \"TechStack\","] # [doc = "  \"description\": \"A specific technology item chosen for the project (e.g., 'React', 'Tokio').\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"type\","] # [doc = "        \"version_constraint\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"TechStack\""] # [doc = "        },"] # [doc = "        \"reason\": {"] # [doc = "          \"description\": \"Ideally referencing an ADR or decision.\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Language\","] # [doc = "            \"Framework\","] # [doc = "            \"Library\","] # [doc = "            \"Database\","] # [doc = "            \"Runtime\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"version_constraint\": {"] # [doc = "          \"description\": \"e.g., '^1.2.0'\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"website\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"uri\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct TechStack { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , pub kind : TechStackKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Ideally referencing an ADR or decision."] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub reason : :: std :: option :: Option < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (rename = "type")] pub type_ : TechStackType , # [doc = "e.g., '^1.2.0'"] pub version_constraint : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub website : :: std :: option :: Option < :: std :: string :: String > , } impl :: std :: convert :: From < & TechStack > for TechStack { fn from (value : & TechStack) -> Self { value . clone () } } impl TechStack { pub fn builder () -> builder :: TechStack { Default :: default () } } # [doc = "`TechStackKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"TechStack\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TechStackKind { TechStack , } impl :: std :: convert :: From < & Self > for TechStackKind { fn from (value : & TechStackKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for TechStackKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: TechStack => f . write_str ("TechStack") , } } } impl :: std :: str :: FromStr for TechStackKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "TechStack" => Ok (Self :: TechStack) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TechStackKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TechStackKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TechStackKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`TechStackType`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Language\","] # [doc = "    \"Framework\","] # [doc = "    \"Library\","] # [doc = "    \"Database\","] # [doc = "    \"Runtime\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TechStackType { Language , Framework , Library , Database , Runtime , } impl :: std :: convert :: From < & Self > for TechStackType { fn from (value : & TechStackType) -> Self { value . clone () } } impl :: std :: fmt :: Display for TechStackType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Language => f . write_str ("Language") , Self :: Framework => f . write_str ("Framework") , Self :: Library => f . write_str ("Library") , Self :: Database => f . write_str ("Database") , Self :: Runtime => f . write_str ("Runtime") , } } } impl :: std :: str :: FromStr for TechStackType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Language" => Ok (Self :: Language) , "Framework" => Ok (Self :: Framework) , "Library" => Ok (Self :: Library) , "Database" => Ok (Self :: Database) , "Runtime" => Ok (Self :: Runtime) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TechStackType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TechStackType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TechStackType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A verifiable test specification (SWEBOK: Software Testing)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/test_case.schema.json\","] # [doc = "  \"title\": \"TestCase\","] # [doc = "  \"description\": \"A verifiable test specification (SWEBOK: Software Testing).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"expected_result\","] # [doc = "        \"kind\","] # [doc = "        \"steps\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"expected_result\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"TestCase\""] # [doc = "        },"] # [doc = "        \"postconditions\": {"] # [doc = "          \"description\": \"State expected after the test (e.g., database cleanup).\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"preconditions\": {"] # [doc = "          \"description\": \"State required before running the test.\","] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"steps\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"test_data\": {"] # [doc = "          \"description\": \"Input data used for the test.\","] # [doc = "          \"type\": \"object\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct TestCase { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub expected_result : :: std :: string :: String , pub id : :: uuid :: Uuid , pub kind : TestCaseKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "State expected after the test (e.g., database cleanup)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub postconditions : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "State required before running the test."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub preconditions : :: std :: vec :: Vec < :: std :: string :: String > , pub steps : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [doc = "Input data used for the test."] # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub test_data : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , } impl :: std :: convert :: From < & TestCase > for TestCase { fn from (value : & TestCase) -> Self { value . clone () } } impl TestCase { pub fn builder () -> builder :: TestCase { Default :: default () } } # [doc = "`TestCaseKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"TestCase\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TestCaseKind { TestCase , } impl :: std :: convert :: From < & Self > for TestCaseKind { fn from (value : & TestCaseKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for TestCaseKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: TestCase => f . write_str ("TestCase") , } } } impl :: std :: str :: FromStr for TestCaseKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "TestCase" => Ok (Self :: TestCase) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TestCaseKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TestCaseKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TestCaseKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "The outcome of a test case execution (Professional Grade)."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/test_result.schema.json\","] # [doc = "  \"title\": \"TestResult\","] # [doc = "  \"description\": \"The outcome of a test case execution (Professional Grade).\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"kind\","] # [doc = "        \"outcome\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"duration_ms\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"minimum\": 0.0"] # [doc = "        },"] # [doc = "        \"environment_ref\": {"] # [doc = "          \"description\": \"ID of the Environment where this ran\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"error_message\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"executed_at\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"date-time\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"TestResult\""] # [doc = "        },"] # [doc = "        \"logs\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"outcome\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Pass\","] # [doc = "            \"Fail\","] # [doc = "            \"Error\","] # [doc = "            \"Skipped\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct TestResult { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub duration_ms : :: std :: option :: Option < u64 > , # [doc = "ID of the Environment where this ran"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub environment_ref : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub error_message : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub executed_at : :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , pub id : :: uuid :: Uuid , pub kind : TestResultKind , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub logs : :: std :: option :: Option < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , pub outcome : TestResultOutcome , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , } impl :: std :: convert :: From < & TestResult > for TestResult { fn from (value : & TestResult) -> Self { value . clone () } } impl TestResult { pub fn builder () -> builder :: TestResult { Default :: default () } } # [doc = "`TestResultKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"TestResult\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TestResultKind { TestResult , } impl :: std :: convert :: From < & Self > for TestResultKind { fn from (value : & TestResultKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for TestResultKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: TestResult => f . write_str ("TestResult") , } } } impl :: std :: str :: FromStr for TestResultKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "TestResult" => Ok (Self :: TestResult) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TestResultKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TestResultKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TestResultKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`TestResultOutcome`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Pass\","] # [doc = "    \"Fail\","] # [doc = "    \"Error\","] # [doc = "    \"Skipped\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum TestResultOutcome { Pass , Fail , Error , Skipped , } impl :: std :: convert :: From < & Self > for TestResultOutcome { fn from (value : & TestResultOutcome) -> Self { value . clone () } } impl :: std :: fmt :: Display for TestResultOutcome { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Pass => f . write_str ("Pass") , Self :: Fail => f . write_str ("Fail") , Self :: Error => f . write_str ("Error") , Self :: Skipped => f . write_str ("Skipped") , } } } impl :: std :: str :: FromStr for TestResultOutcome { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Pass" => Ok (Self :: Pass) , "Fail" => Ok (Self :: Fail) , "Error" => Ok (Self :: Error) , "Skipped" => Ok (Self :: Skipped) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for TestResultOutcome { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for TestResultOutcome { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for TestResultOutcome { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "A specific software tool or service required by the environment."] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://infinite-coding-loop.dass/schemas/entities/tool.schema.json\","] # [doc = "  \"title\": \"Tool\","] # [doc = "  \"description\": \"A specific software tool or service required by the environment.\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"https://infinite-coding-loop.dass/schemas/taxonomy.schema.json#/definitions/EntityMetadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"category\","] # [doc = "        \"command_name\","] # [doc = "        \"kind\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"category\": {"] # [doc = "          \"enum\": ["] # [doc = "            \"Compiler\","] # [doc = "            \"Linter\","] # [doc = "            \"Database\","] # [doc = "            \"Server\","] # [doc = "            \"CLI\","] # [doc = "            \"Editor\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"command_name\": {"] # [doc = "          \"description\": \"The executable name (e.g., 'cargo', 'npm').\","] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"installation_guide\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"kind\": {"] # [doc = "          \"const\": \"Tool\""] # [doc = "        },"] # [doc = "        \"version_requirement\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Tool { pub category : ToolCategory , # [doc = "The executable name (e.g., 'cargo', 'npm')."] pub command_name : :: std :: string :: String , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub description : :: std :: option :: Option < :: std :: string :: String > , pub id : :: uuid :: Uuid , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub installation_guide : :: std :: option :: Option < :: std :: string :: String > , pub kind : ToolKind , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub metadata : :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , pub name : :: std :: string :: String , # [doc = "Alternative names for this entity (e.g., Feature -> Epic)."] # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub synonyms : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::vec::Vec::is_empty")] pub tags : :: std :: vec :: Vec < :: std :: string :: String > , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub version_requirement : :: std :: option :: Option < :: std :: string :: String > , } impl :: std :: convert :: From < & Tool > for Tool { fn from (value : & Tool) -> Self { value . clone () } } impl Tool { pub fn builder () -> builder :: Tool { Default :: default () } } # [doc = "`ToolCategory`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"enum\": ["] # [doc = "    \"Compiler\","] # [doc = "    \"Linter\","] # [doc = "    \"Database\","] # [doc = "    \"Server\","] # [doc = "    \"CLI\","] # [doc = "    \"Editor\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ToolCategory { Compiler , Linter , Database , Server , # [serde (rename = "CLI")] Cli , Editor , } impl :: std :: convert :: From < & Self > for ToolCategory { fn from (value : & ToolCategory) -> Self { value . clone () } } impl :: std :: fmt :: Display for ToolCategory { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Compiler => f . write_str ("Compiler") , Self :: Linter => f . write_str ("Linter") , Self :: Database => f . write_str ("Database") , Self :: Server => f . write_str ("Server") , Self :: Cli => f . write_str ("CLI") , Self :: Editor => f . write_str ("Editor") , } } } impl :: std :: str :: FromStr for ToolCategory { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Compiler" => Ok (Self :: Compiler) , "Linter" => Ok (Self :: Linter) , "Database" => Ok (Self :: Database) , "Server" => Ok (Self :: Server) , "CLI" => Ok (Self :: Cli) , "Editor" => Ok (Self :: Editor) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ToolCategory { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ToolCategory { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ToolCategory { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`ToolKind`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Tool\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ToolKind { Tool , } impl :: std :: convert :: From < & Self > for ToolKind { fn from (value : & ToolKind) -> Self { value . clone () } } impl :: std :: fmt :: Display for ToolKind { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Tool => f . write_str ("Tool") , } } } impl :: std :: str :: FromStr for ToolKind { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "Tool" => Ok (Self :: Tool) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for ToolKind { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ToolKind { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ToolKind { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = r" Types for composing complex structures."] pub mod builder { # [derive (Clone , Debug)] pub struct Agent { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: AgentKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , responsibilities : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , role : :: std :: result :: Result < super :: AgentRole , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , system_prompt : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tools : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Agent { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , responsibilities : Err ("no value supplied for responsibilities" . to_string ()) , role : Err ("no value supplied for role" . to_string ()) , synonyms : Ok (Default :: default ()) , system_prompt : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , tools : Ok (Default :: default ()) , } } } impl Agent { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: AgentKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn responsibilities < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . responsibilities = value . try_into () . map_err (| e | format ! ("error converting supplied value for responsibilities: {}" , e)) ; self } pub fn role < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: AgentRole > , T :: Error : :: std :: fmt :: Display , { self . role = value . try_into () . map_err (| e | format ! ("error converting supplied value for role: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn system_prompt < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . system_prompt = value . try_into () . map_err (| e | format ! ("error converting supplied value for system_prompt: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn tools < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tools = value . try_into () . map_err (| e | format ! ("error converting supplied value for tools: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Agent > for super :: Agent { type Error = super :: error :: ConversionError ; fn try_from (value : Agent) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , responsibilities : value . responsibilities ? , role : value . role ? , synonyms : value . synonyms ? , system_prompt : value . system_prompt ? , tags : value . tags ? , tools : value . tools ? , }) } } impl :: std :: convert :: From < super :: Agent > for Agent { fn from (value : super :: Agent) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , responsibilities : Ok (value . responsibilities) , role : Ok (value . role) , synonyms : Ok (value . synonyms) , system_prompt : Ok (value . system_prompt) , tags : Ok (value . tags) , tools : Ok (value . tools) , } } } # [derive (Clone , Debug)] pub struct ArchitectureComponent { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ArchitectureComponentKind , :: std :: string :: String > , layer : :: std :: result :: Result < super :: ArchitectureComponentLayer , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for ArchitectureComponent { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , layer : Err ("no value supplied for layer" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl ArchitectureComponent { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ArchitectureComponentKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn layer < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ArchitectureComponentLayer > , T :: Error : :: std :: fmt :: Display , { self . layer = value . try_into () . map_err (| e | format ! ("error converting supplied value for layer: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < ArchitectureComponent > for super :: ArchitectureComponent { type Error = super :: error :: ConversionError ; fn try_from (value : ArchitectureComponent) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , layer : value . layer ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: ArchitectureComponent > for ArchitectureComponent { fn from (value : super :: ArchitectureComponent) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , layer : Ok (value . layer) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct ArchitecturePattern { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ArchitecturePatternKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , principles : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , structure_diagram : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , type_ : :: std :: result :: Result < super :: ArchitecturePatternType , :: std :: string :: String > , } impl :: std :: default :: Default for ArchitecturePattern { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , principles : Ok (Default :: default ()) , structure_diagram : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , type_ : Err ("no value supplied for type_" . to_string ()) , } } } impl ArchitecturePattern { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ArchitecturePatternKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn principles < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . principles = value . try_into () . map_err (| e | format ! ("error converting supplied value for principles: {}" , e)) ; self } pub fn structure_diagram < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . structure_diagram = value . try_into () . map_err (| e | format ! ("error converting supplied value for structure_diagram: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ArchitecturePatternType > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < ArchitecturePattern > for super :: ArchitecturePattern { type Error = super :: error :: ConversionError ; fn try_from (value : ArchitecturePattern) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , principles : value . principles ? , structure_diagram : value . structure_diagram ? , synonyms : value . synonyms ? , tags : value . tags ? , type_ : value . type_ ? , }) } } impl :: std :: convert :: From < super :: ArchitecturePattern > for ArchitecturePattern { fn from (value : super :: ArchitecturePattern) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , principles : Ok (value . principles) , structure_diagram : Ok (value . structure_diagram) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , type_ : Ok (value . type_) , } } } # [derive (Clone , Debug)] pub struct ChangeRequest { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ChangeRequestKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , reason : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , status : :: std :: result :: Result < super :: ChangeRequestStatus , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , target_entity_id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , } impl :: std :: default :: Default for ChangeRequest { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , reason : Ok (Default :: default ()) , status : Err ("no value supplied for status" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , target_entity_id : Err ("no value supplied for target_entity_id" . to_string ()) , } } } impl ChangeRequest { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ChangeRequestKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn reason < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . reason = value . try_into () . map_err (| e | format ! ("error converting supplied value for reason: {}" , e)) ; self } pub fn status < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ChangeRequestStatus > , T :: Error : :: std :: fmt :: Display , { self . status = value . try_into () . map_err (| e | format ! ("error converting supplied value for status: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn target_entity_id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . target_entity_id = value . try_into () . map_err (| e | format ! ("error converting supplied value for target_entity_id: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < ChangeRequest > for super :: ChangeRequest { type Error = super :: error :: ConversionError ; fn try_from (value : ChangeRequest) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , reason : value . reason ? , status : value . status ? , synonyms : value . synonyms ? , tags : value . tags ? , target_entity_id : value . target_entity_id ? , }) } } impl :: std :: convert :: From < super :: ChangeRequest > for ChangeRequest { fn from (value : super :: ChangeRequest) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , reason : Ok (value . reason) , status : Ok (value . status) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , target_entity_id : Ok (value . target_entity_id) , } } } # [derive (Clone , Debug)] pub struct Command { arguments : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , executable : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: CommandKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Command { fn default () -> Self { Self { arguments : Ok (Default :: default ()) , description : Ok (Default :: default ()) , executable : Err ("no value supplied for executable" . to_string ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Command { pub fn arguments < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . arguments = value . try_into () . map_err (| e | format ! ("error converting supplied value for arguments: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn executable < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . executable = value . try_into () . map_err (| e | format ! ("error converting supplied value for executable: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: CommandKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Command > for super :: Command { type Error = super :: error :: ConversionError ; fn try_from (value : Command) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { arguments : value . arguments ? , description : value . description ? , executable : value . executable ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Command > for Command { fn from (value : super :: Command) -> Self { Self { arguments : Ok (value . arguments) , description : Ok (value . description) , executable : Ok (value . executable) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct DataModel { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: DataModelKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , schema_definition : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for DataModel { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , schema_definition : Err ("no value supplied for schema_definition" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl DataModel { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: DataModelKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn schema_definition < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . schema_definition = value . try_into () . map_err (| e | format ! ("error converting supplied value for schema_definition: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DataModel > for super :: DataModel { type Error = super :: error :: ConversionError ; fn try_from (value : DataModel) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , schema_definition : value . schema_definition ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: DataModel > for DataModel { fn from (value : super :: DataModel) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , schema_definition : Ok (value . schema_definition) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct DesignSpec { data_spec : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: DesignSpecKind , :: std :: string :: String > , logic_spec : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , ui_spec : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , verification_plan : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for DesignSpec { fn default () -> Self { Self { data_spec : Ok (Default :: default ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , logic_spec : Ok (Default :: default ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , ui_spec : Ok (Default :: default ()) , verification_plan : Ok (Default :: default ()) , } } } impl DesignSpec { pub fn data_spec < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . data_spec = value . try_into () . map_err (| e | format ! ("error converting supplied value for data_spec: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: DesignSpecKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn logic_spec < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . logic_spec = value . try_into () . map_err (| e | format ! ("error converting supplied value for logic_spec: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn ui_spec < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . ui_spec = value . try_into () . map_err (| e | format ! ("error converting supplied value for ui_spec: {}" , e)) ; self } pub fn verification_plan < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . verification_plan = value . try_into () . map_err (| e | format ! ("error converting supplied value for verification_plan: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DesignSpec > for super :: DesignSpec { type Error = super :: error :: ConversionError ; fn try_from (value : DesignSpec) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { data_spec : value . data_spec ? , description : value . description ? , id : value . id ? , kind : value . kind ? , logic_spec : value . logic_spec ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , ui_spec : value . ui_spec ? , verification_plan : value . verification_plan ? , }) } } impl :: std :: convert :: From < super :: DesignSpec > for DesignSpec { fn from (value : super :: DesignSpec) -> Self { Self { data_spec : Ok (value . data_spec) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , logic_spec : Ok (value . logic_spec) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , ui_spec : Ok (value . ui_spec) , verification_plan : Ok (value . verification_plan) , } } } # [derive (Clone , Debug)] pub struct DomainEntity { attributes : :: std :: result :: Result < :: std :: vec :: Vec < super :: DomainEntityAttributesItem > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: DomainEntityKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , relationships : :: std :: result :: Result < :: std :: vec :: Vec < super :: DomainEntityRelationshipsItem > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for DomainEntity { fn default () -> Self { Self { attributes : Err ("no value supplied for attributes" . to_string ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , relationships : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl DomainEntity { pub fn attributes < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: DomainEntityAttributesItem > > , T :: Error : :: std :: fmt :: Display , { self . attributes = value . try_into () . map_err (| e | format ! ("error converting supplied value for attributes: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: DomainEntityKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn relationships < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: DomainEntityRelationshipsItem > > , T :: Error : :: std :: fmt :: Display , { self . relationships = value . try_into () . map_err (| e | format ! ("error converting supplied value for relationships: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DomainEntity > for super :: DomainEntity { type Error = super :: error :: ConversionError ; fn try_from (value : DomainEntity) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { attributes : value . attributes ? , description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , relationships : value . relationships ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: DomainEntity > for DomainEntity { fn from (value : super :: DomainEntity) -> Self { Self { attributes : Ok (value . attributes) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , relationships : Ok (value . relationships) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct DomainEntityAttributesItem { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , is_primary_key : :: std :: result :: Result < :: std :: option :: Option < bool > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , required : :: std :: result :: Result < :: std :: option :: Option < bool > , :: std :: string :: String > , type_ : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for DomainEntityAttributesItem { fn default () -> Self { Self { description : Ok (Default :: default ()) , is_primary_key : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , required : Ok (Default :: default ()) , type_ : Err ("no value supplied for type_" . to_string ()) , } } } impl DomainEntityAttributesItem { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn is_primary_key < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < bool > > , T :: Error : :: std :: fmt :: Display , { self . is_primary_key = value . try_into () . map_err (| e | format ! ("error converting supplied value for is_primary_key: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn required < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < bool > > , T :: Error : :: std :: fmt :: Display , { self . required = value . try_into () . map_err (| e | format ! ("error converting supplied value for required: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DomainEntityAttributesItem > for super :: DomainEntityAttributesItem { type Error = super :: error :: ConversionError ; fn try_from (value : DomainEntityAttributesItem) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , is_primary_key : value . is_primary_key ? , name : value . name ? , required : value . required ? , type_ : value . type_ ? , }) } } impl :: std :: convert :: From < super :: DomainEntityAttributesItem > for DomainEntityAttributesItem { fn from (value : super :: DomainEntityAttributesItem) -> Self { Self { description : Ok (value . description) , is_primary_key : Ok (value . is_primary_key) , name : Ok (value . name) , required : Ok (value . required) , type_ : Ok (value . type_) , } } } # [derive (Clone , Debug)] pub struct DomainEntityRelationshipsItem { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , relation_type : :: std :: result :: Result < super :: DomainEntityRelationshipsItemRelationType , :: std :: string :: String > , target_entity : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for DomainEntityRelationshipsItem { fn default () -> Self { Self { description : Ok (Default :: default ()) , relation_type : Err ("no value supplied for relation_type" . to_string ()) , target_entity : Err ("no value supplied for target_entity" . to_string ()) , } } } impl DomainEntityRelationshipsItem { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn relation_type < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: DomainEntityRelationshipsItemRelationType > , T :: Error : :: std :: fmt :: Display , { self . relation_type = value . try_into () . map_err (| e | format ! ("error converting supplied value for relation_type: {}" , e)) ; self } pub fn target_entity < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . target_entity = value . try_into () . map_err (| e | format ! ("error converting supplied value for target_entity: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < DomainEntityRelationshipsItem > for super :: DomainEntityRelationshipsItem { type Error = super :: error :: ConversionError ; fn try_from (value : DomainEntityRelationshipsItem) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , relation_type : value . relation_type ? , target_entity : value . target_entity ? , }) } } impl :: std :: convert :: From < super :: DomainEntityRelationshipsItem > for DomainEntityRelationshipsItem { fn from (value : super :: DomainEntityRelationshipsItem) -> Self { Self { description : Ok (value . description) , relation_type : Ok (value . relation_type) , target_entity : Ok (value . target_entity) , } } } # [derive (Clone , Debug)] pub struct EntityMetadata { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for EntityMetadata { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl EntityMetadata { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < EntityMetadata > for super :: EntityMetadata { type Error = super :: error :: ConversionError ; fn try_from (value : EntityMetadata) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: EntityMetadata > for EntityMetadata { fn from (value : super :: EntityMetadata) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Environment { container_image : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , env_variables : :: std :: result :: Result < :: std :: collections :: HashMap < :: std :: string :: String , :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: EnvironmentKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , os : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , secrets : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tools : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , type_ : :: std :: result :: Result < super :: EnvironmentType , :: std :: string :: String > , } impl :: std :: default :: Default for Environment { fn default () -> Self { Self { container_image : Ok (Default :: default ()) , description : Ok (Default :: default ()) , env_variables : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , os : Ok (Default :: default ()) , secrets : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , tools : Ok (Default :: default ()) , type_ : Err ("no value supplied for type_" . to_string ()) , } } } impl Environment { pub fn container_image < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . container_image = value . try_into () . map_err (| e | format ! ("error converting supplied value for container_image: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn env_variables < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: collections :: HashMap < :: std :: string :: String , :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . env_variables = value . try_into () . map_err (| e | format ! ("error converting supplied value for env_variables: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: EnvironmentKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn os < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . os = value . try_into () . map_err (| e | format ! ("error converting supplied value for os: {}" , e)) ; self } pub fn secrets < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . secrets = value . try_into () . map_err (| e | format ! ("error converting supplied value for secrets: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn tools < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tools = value . try_into () . map_err (| e | format ! ("error converting supplied value for tools: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: EnvironmentType > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Environment > for super :: Environment { type Error = super :: error :: ConversionError ; fn try_from (value : Environment) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { container_image : value . container_image ? , description : value . description ? , env_variables : value . env_variables ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , os : value . os ? , secrets : value . secrets ? , synonyms : value . synonyms ? , tags : value . tags ? , tools : value . tools ? , type_ : value . type_ ? , }) } } impl :: std :: convert :: From < super :: Environment > for Environment { fn from (value : super :: Environment) -> Self { Self { container_image : Ok (value . container_image) , description : Ok (value . description) , env_variables : Ok (value . env_variables) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , os : Ok (value . os) , secrets : Ok (value . secrets) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , tools : Ok (value . tools) , type_ : Ok (value . type_) , } } } # [derive (Clone , Debug)] pub struct Feature { business_value : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: FeatureKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , priority : :: std :: result :: Result < super :: FeaturePriority , :: std :: string :: String > , status : :: std :: result :: Result < super :: FeatureStatus , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Feature { fn default () -> Self { Self { business_value : Err ("no value supplied for business_value" . to_string ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , priority : Err ("no value supplied for priority" . to_string ()) , status : Ok (super :: defaults :: feature_status ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Feature { pub fn business_value < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . business_value = value . try_into () . map_err (| e | format ! ("error converting supplied value for business_value: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: FeatureKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn priority < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: FeaturePriority > , T :: Error : :: std :: fmt :: Display , { self . priority = value . try_into () . map_err (| e | format ! ("error converting supplied value for priority: {}" , e)) ; self } pub fn status < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: FeatureStatus > , T :: Error : :: std :: fmt :: Display , { self . status = value . try_into () . map_err (| e | format ! ("error converting supplied value for status: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Feature > for super :: Feature { type Error = super :: error :: ConversionError ; fn try_from (value : Feature) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { business_value : value . business_value ? , description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , priority : value . priority ? , status : value . status ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Feature > for Feature { fn from (value : super :: Feature) -> Self { Self { business_value : Ok (value . business_value) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , priority : Ok (value . priority) , status : Ok (value . status) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct FileSystemNode { children : :: std :: result :: Result < :: std :: vec :: Vec < super :: FileSystemNode > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , type_ : :: std :: result :: Result < super :: FileSystemNodeType , :: std :: string :: String > , } impl :: std :: default :: Default for FileSystemNode { fn default () -> Self { Self { children : Ok (Default :: default ()) , description : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , type_ : Err ("no value supplied for type_" . to_string ()) , } } } impl FileSystemNode { pub fn children < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: FileSystemNode > > , T :: Error : :: std :: fmt :: Display , { self . children = value . try_into () . map_err (| e | format ! ("error converting supplied value for children: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: FileSystemNodeType > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < FileSystemNode > for super :: FileSystemNode { type Error = super :: error :: ConversionError ; fn try_from (value : FileSystemNode) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { children : value . children ? , description : value . description ? , name : value . name ? , type_ : value . type_ ? , }) } } impl :: std :: convert :: From < super :: FileSystemNode > for FileSystemNode { fn from (value : super :: FileSystemNode) -> Self { Self { children : Ok (value . children) , description : Ok (value . description) , name : Ok (value . name) , type_ : Ok (value . type_) , } } } # [derive (Clone , Debug)] pub struct Observation { artifact_id : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , context : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , insight : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ObservationKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , observed_at : :: std :: result :: Result < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , :: std :: string :: String > , recommendation : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , severity : :: std :: result :: Result < super :: ObservationSeverity , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Observation { fn default () -> Self { Self { artifact_id : Ok (Default :: default ()) , context : Ok (Default :: default ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , insight : Err ("no value supplied for insight" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , observed_at : Ok (Default :: default ()) , recommendation : Ok (Default :: default ()) , severity : Err ("no value supplied for severity" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Observation { pub fn artifact_id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . artifact_id = value . try_into () . map_err (| e | format ! ("error converting supplied value for artifact_id: {}" , e)) ; self } pub fn context < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . context = value . try_into () . map_err (| e | format ! ("error converting supplied value for context: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn insight < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . insight = value . try_into () . map_err (| e | format ! ("error converting supplied value for insight: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ObservationKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn observed_at < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > > , T :: Error : :: std :: fmt :: Display , { self . observed_at = value . try_into () . map_err (| e | format ! ("error converting supplied value for observed_at: {}" , e)) ; self } pub fn recommendation < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . recommendation = value . try_into () . map_err (| e | format ! ("error converting supplied value for recommendation: {}" , e)) ; self } pub fn severity < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ObservationSeverity > , T :: Error : :: std :: fmt :: Display , { self . severity = value . try_into () . map_err (| e | format ! ("error converting supplied value for severity: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Observation > for super :: Observation { type Error = super :: error :: ConversionError ; fn try_from (value : Observation) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { artifact_id : value . artifact_id ? , context : value . context ? , description : value . description ? , id : value . id ? , insight : value . insight ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , observed_at : value . observed_at ? , recommendation : value . recommendation ? , severity : value . severity ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Observation > for Observation { fn from (value : super :: Observation) -> Self { Self { artifact_id : Ok (value . artifact_id) , context : Ok (value . context) , description : Ok (value . description) , id : Ok (value . id) , insight : Ok (value . insight) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , observed_at : Ok (value . observed_at) , recommendation : Ok (value . recommendation) , severity : Ok (value . severity) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Persona { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: PersonaKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , responsibilities : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , role : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Persona { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , responsibilities : Ok (Default :: default ()) , role : Err ("no value supplied for role" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Persona { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: PersonaKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn responsibilities < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . responsibilities = value . try_into () . map_err (| e | format ! ("error converting supplied value for responsibilities: {}" , e)) ; self } pub fn role < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . role = value . try_into () . map_err (| e | format ! ("error converting supplied value for role: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Persona > for super :: Persona { type Error = super :: error :: ConversionError ; fn try_from (value : Persona) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , responsibilities : value . responsibilities ? , role : value . role ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Persona > for Persona { fn from (value : super :: Persona) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , responsibilities : Ok (value . responsibilities) , role : Ok (value . role) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Plan { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: PlanKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tasks : :: std :: result :: Result < :: std :: vec :: Vec < super :: PlanTasksItem > , :: std :: string :: String > , } impl :: std :: default :: Default for Plan { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , tasks : Err ("no value supplied for tasks" . to_string ()) , } } } impl Plan { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: PlanKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn tasks < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: PlanTasksItem > > , T :: Error : :: std :: fmt :: Display , { self . tasks = value . try_into () . map_err (| e | format ! ("error converting supplied value for tasks: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Plan > for super :: Plan { type Error = super :: error :: ConversionError ; fn try_from (value : Plan) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , tasks : value . tasks ? , }) } } impl :: std :: convert :: From < super :: Plan > for Plan { fn from (value : super :: Plan) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , tasks : Ok (value . tasks) , } } } # [derive (Clone , Debug)] pub struct PlanTasksItem { dependencies : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , estimated_duration : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for PlanTasksItem { fn default () -> Self { Self { dependencies : Ok (Default :: default ()) , description : Err ("no value supplied for description" . to_string ()) , estimated_duration : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , } } } impl PlanTasksItem { pub fn dependencies < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . dependencies = value . try_into () . map_err (| e | format ! ("error converting supplied value for dependencies: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn estimated_duration < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . estimated_duration = value . try_into () . map_err (| e | format ! ("error converting supplied value for estimated_duration: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < PlanTasksItem > for super :: PlanTasksItem { type Error = super :: error :: ConversionError ; fn try_from (value : PlanTasksItem) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { dependencies : value . dependencies ? , description : value . description ? , estimated_duration : value . estimated_duration ? , id : value . id ? , }) } } impl :: std :: convert :: From < super :: PlanTasksItem > for PlanTasksItem { fn from (value : super :: PlanTasksItem) -> Self { Self { dependencies : Ok (value . dependencies) , description : Ok (value . description) , estimated_duration : Ok (value . estimated_duration) , id : Ok (value . id) , } } } # [derive (Clone , Debug)] pub struct ProjectStructure { conventions : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ProjectStructureKind , :: std :: string :: String > , layout : :: std :: result :: Result < :: std :: vec :: Vec < super :: FileSystemNode > , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , root_path : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for ProjectStructure { fn default () -> Self { Self { conventions : Ok (Default :: default ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , layout : Err ("no value supplied for layout" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , root_path : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl ProjectStructure { pub fn conventions < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . conventions = value . try_into () . map_err (| e | format ! ("error converting supplied value for conventions: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ProjectStructureKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn layout < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < super :: FileSystemNode > > , T :: Error : :: std :: fmt :: Display , { self . layout = value . try_into () . map_err (| e | format ! ("error converting supplied value for layout: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn root_path < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . root_path = value . try_into () . map_err (| e | format ! ("error converting supplied value for root_path: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < ProjectStructure > for super :: ProjectStructure { type Error = super :: error :: ConversionError ; fn try_from (value : ProjectStructure) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { conventions : value . conventions ? , description : value . description ? , id : value . id ? , kind : value . kind ? , layout : value . layout ? , metadata : value . metadata ? , name : value . name ? , root_path : value . root_path ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: ProjectStructure > for ProjectStructure { fn from (value : super :: ProjectStructure) -> Self { Self { conventions : Ok (value . conventions) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , layout : Ok (value . layout) , metadata : Ok (value . metadata) , name : Ok (value . name) , root_path : Ok (value . root_path) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Requirement { acceptance_criteria : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: RequirementKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , priority : :: std :: result :: Result < :: std :: option :: Option < super :: RequirementPriority > , :: std :: string :: String > , req_type : :: std :: result :: Result < super :: RequirementReqType , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , user_story : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for Requirement { fn default () -> Self { Self { acceptance_criteria : Err ("no value supplied for acceptance_criteria" . to_string ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , priority : Ok (Default :: default ()) , req_type : Err ("no value supplied for req_type" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , user_story : Err ("no value supplied for user_story" . to_string ()) , } } } impl Requirement { pub fn acceptance_criteria < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . acceptance_criteria = value . try_into () . map_err (| e | format ! ("error converting supplied value for acceptance_criteria: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RequirementKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn priority < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < super :: RequirementPriority > > , T :: Error : :: std :: fmt :: Display , { self . priority = value . try_into () . map_err (| e | format ! ("error converting supplied value for priority: {}" , e)) ; self } pub fn req_type < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RequirementReqType > , T :: Error : :: std :: fmt :: Display , { self . req_type = value . try_into () . map_err (| e | format ! ("error converting supplied value for req_type: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn user_story < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . user_story = value . try_into () . map_err (| e | format ! ("error converting supplied value for user_story: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Requirement > for super :: Requirement { type Error = super :: error :: ConversionError ; fn try_from (value : Requirement) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { acceptance_criteria : value . acceptance_criteria ? , description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , priority : value . priority ? , req_type : value . req_type ? , synonyms : value . synonyms ? , tags : value . tags ? , user_story : value . user_story ? , }) } } impl :: std :: convert :: From < super :: Requirement > for Requirement { fn from (value : super :: Requirement) -> Self { Self { acceptance_criteria : Ok (value . acceptance_criteria) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , priority : Ok (value . priority) , req_type : Ok (value . req_type) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , user_story : Ok (value . user_story) , } } } # [derive (Clone , Debug)] pub struct Risk { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , impact : :: std :: result :: Result < super :: RiskImpact , :: std :: string :: String > , kind : :: std :: result :: Result < super :: RiskKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , mitigation_plan : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , probability : :: std :: result :: Result < super :: RiskProbability , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Risk { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , impact : Err ("no value supplied for impact" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , mitigation_plan : Err ("no value supplied for mitigation_plan" . to_string ()) , name : Err ("no value supplied for name" . to_string ()) , probability : Err ("no value supplied for probability" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Risk { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn impact < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RiskImpact > , T :: Error : :: std :: fmt :: Display , { self . impact = value . try_into () . map_err (| e | format ! ("error converting supplied value for impact: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RiskKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn mitigation_plan < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . mitigation_plan = value . try_into () . map_err (| e | format ! ("error converting supplied value for mitigation_plan: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn probability < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: RiskProbability > , T :: Error : :: std :: fmt :: Display , { self . probability = value . try_into () . map_err (| e | format ! ("error converting supplied value for probability: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Risk > for super :: Risk { type Error = super :: error :: ConversionError ; fn try_from (value : Risk) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , impact : value . impact ? , kind : value . kind ? , metadata : value . metadata ? , mitigation_plan : value . mitigation_plan ? , name : value . name ? , probability : value . probability ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Risk > for Risk { fn from (value : super :: Risk) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , impact : Ok (value . impact) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , mitigation_plan : Ok (value . mitigation_plan) , name : Ok (value . name) , probability : Ok (value . probability) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct SoftwareApplication { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: SoftwareApplicationKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , work_dir : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for SoftwareApplication { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , work_dir : Ok (Default :: default ()) , } } } impl SoftwareApplication { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: SoftwareApplicationKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn work_dir < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . work_dir = value . try_into () . map_err (| e | format ! ("error converting supplied value for work_dir: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < SoftwareApplication > for super :: SoftwareApplication { type Error = super :: error :: ConversionError ; fn try_from (value : SoftwareApplication) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , work_dir : value . work_dir ? , }) } } impl :: std :: convert :: From < super :: SoftwareApplication > for SoftwareApplication { fn from (value : super :: SoftwareApplication) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , work_dir : Ok (value . work_dir) , } } } # [derive (Clone , Debug)] pub struct SourceFile { checksum : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , content : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: SourceFileKind , :: std :: string :: String > , language : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , language_version : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , path : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for SourceFile { fn default () -> Self { Self { checksum : Ok (Default :: default ()) , content : Ok (Default :: default ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , language : Err ("no value supplied for language" . to_string ()) , language_version : Ok (Default :: default ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , path : Err ("no value supplied for path" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl SourceFile { pub fn checksum < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . checksum = value . try_into () . map_err (| e | format ! ("error converting supplied value for checksum: {}" , e)) ; self } pub fn content < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . content = value . try_into () . map_err (| e | format ! ("error converting supplied value for content: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: SourceFileKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn language < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . language = value . try_into () . map_err (| e | format ! ("error converting supplied value for language: {}" , e)) ; self } pub fn language_version < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . language_version = value . try_into () . map_err (| e | format ! ("error converting supplied value for language_version: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn path < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . path = value . try_into () . map_err (| e | format ! ("error converting supplied value for path: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < SourceFile > for super :: SourceFile { type Error = super :: error :: ConversionError ; fn try_from (value : SourceFile) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { checksum : value . checksum ? , content : value . content ? , description : value . description ? , id : value . id ? , kind : value . kind ? , language : value . language ? , language_version : value . language_version ? , metadata : value . metadata ? , name : value . name ? , path : value . path ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: SourceFile > for SourceFile { fn from (value : super :: SourceFile) -> Self { Self { checksum : Ok (value . checksum) , content : Ok (value . content) , description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , language : Ok (value . language) , language_version : Ok (value . language_version) , metadata : Ok (value . metadata) , name : Ok (value . name) , path : Ok (value . path) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Standard { category : :: std :: result :: Result < super :: StandardCategory , :: std :: string :: String > , command_template : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , compliance_level : :: std :: result :: Result < super :: StandardComplianceLevel , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , enforcement_tool : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: StandardKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , rules : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Standard { fn default () -> Self { Self { category : Err ("no value supplied for category" . to_string ()) , command_template : Ok (Default :: default ()) , compliance_level : Ok (super :: defaults :: standard_compliance_level ()) , description : Ok (Default :: default ()) , enforcement_tool : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , rules : Err ("no value supplied for rules" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl Standard { pub fn category < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: StandardCategory > , T :: Error : :: std :: fmt :: Display , { self . category = value . try_into () . map_err (| e | format ! ("error converting supplied value for category: {}" , e)) ; self } pub fn command_template < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . command_template = value . try_into () . map_err (| e | format ! ("error converting supplied value for command_template: {}" , e)) ; self } pub fn compliance_level < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: StandardComplianceLevel > , T :: Error : :: std :: fmt :: Display , { self . compliance_level = value . try_into () . map_err (| e | format ! ("error converting supplied value for compliance_level: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn enforcement_tool < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . enforcement_tool = value . try_into () . map_err (| e | format ! ("error converting supplied value for enforcement_tool: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: StandardKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn rules < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . rules = value . try_into () . map_err (| e | format ! ("error converting supplied value for rules: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Standard > for super :: Standard { type Error = super :: error :: ConversionError ; fn try_from (value : Standard) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { category : value . category ? , command_template : value . command_template ? , compliance_level : value . compliance_level ? , description : value . description ? , enforcement_tool : value . enforcement_tool ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , rules : value . rules ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: Standard > for Standard { fn from (value : super :: Standard) -> Self { Self { category : Ok (value . category) , command_template : Ok (value . command_template) , compliance_level : Ok (value . compliance_level) , description : Ok (value . description) , enforcement_tool : Ok (value . enforcement_tool) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , rules : Ok (value . rules) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct TechStack { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: TechStackKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , reason : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , type_ : :: std :: result :: Result < super :: TechStackType , :: std :: string :: String > , version_constraint : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , website : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for TechStack { fn default () -> Self { Self { description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , reason : Ok (Default :: default ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , type_ : Err ("no value supplied for type_" . to_string ()) , version_constraint : Err ("no value supplied for version_constraint" . to_string ()) , website : Ok (Default :: default ()) , } } } impl TechStack { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TechStackKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn reason < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . reason = value . try_into () . map_err (| e | format ! ("error converting supplied value for reason: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn type_ < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TechStackType > , T :: Error : :: std :: fmt :: Display , { self . type_ = value . try_into () . map_err (| e | format ! ("error converting supplied value for type_: {}" , e)) ; self } pub fn version_constraint < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . version_constraint = value . try_into () . map_err (| e | format ! ("error converting supplied value for version_constraint: {}" , e)) ; self } pub fn website < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . website = value . try_into () . map_err (| e | format ! ("error converting supplied value for website: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < TechStack > for super :: TechStack { type Error = super :: error :: ConversionError ; fn try_from (value : TechStack) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , reason : value . reason ? , synonyms : value . synonyms ? , tags : value . tags ? , type_ : value . type_ ? , version_constraint : value . version_constraint ? , website : value . website ? , }) } } impl :: std :: convert :: From < super :: TechStack > for TechStack { fn from (value : super :: TechStack) -> Self { Self { description : Ok (value . description) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , reason : Ok (value . reason) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , type_ : Ok (value . type_) , version_constraint : Ok (value . version_constraint) , website : Ok (value . website) , } } } # [derive (Clone , Debug)] pub struct TestCase { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , expected_result : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: TestCaseKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , postconditions : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , preconditions : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , steps : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , test_data : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , } impl :: std :: default :: Default for TestCase { fn default () -> Self { Self { description : Ok (Default :: default ()) , expected_result : Err ("no value supplied for expected_result" . to_string ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , postconditions : Ok (Default :: default ()) , preconditions : Ok (Default :: default ()) , steps : Err ("no value supplied for steps" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , test_data : Ok (Default :: default ()) , } } } impl TestCase { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn expected_result < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . expected_result = value . try_into () . map_err (| e | format ! ("error converting supplied value for expected_result: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TestCaseKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn postconditions < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . postconditions = value . try_into () . map_err (| e | format ! ("error converting supplied value for postconditions: {}" , e)) ; self } pub fn preconditions < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . preconditions = value . try_into () . map_err (| e | format ! ("error converting supplied value for preconditions: {}" , e)) ; self } pub fn steps < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . steps = value . try_into () . map_err (| e | format ! ("error converting supplied value for steps: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn test_data < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . test_data = value . try_into () . map_err (| e | format ! ("error converting supplied value for test_data: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < TestCase > for super :: TestCase { type Error = super :: error :: ConversionError ; fn try_from (value : TestCase) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , expected_result : value . expected_result ? , id : value . id ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , postconditions : value . postconditions ? , preconditions : value . preconditions ? , steps : value . steps ? , synonyms : value . synonyms ? , tags : value . tags ? , test_data : value . test_data ? , }) } } impl :: std :: convert :: From < super :: TestCase > for TestCase { fn from (value : super :: TestCase) -> Self { Self { description : Ok (value . description) , expected_result : Ok (value . expected_result) , id : Ok (value . id) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , postconditions : Ok (value . postconditions) , preconditions : Ok (value . preconditions) , steps : Ok (value . steps) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , test_data : Ok (value . test_data) , } } } # [derive (Clone , Debug)] pub struct TestResult { description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , duration_ms : :: std :: result :: Result < :: std :: option :: Option < u64 > , :: std :: string :: String > , environment_ref : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , error_message : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , executed_at : :: std :: result :: Result < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , kind : :: std :: result :: Result < super :: TestResultKind , :: std :: string :: String > , logs : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , outcome : :: std :: result :: Result < super :: TestResultOutcome , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for TestResult { fn default () -> Self { Self { description : Ok (Default :: default ()) , duration_ms : Ok (Default :: default ()) , environment_ref : Ok (Default :: default ()) , error_message : Ok (Default :: default ()) , executed_at : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , kind : Err ("no value supplied for kind" . to_string ()) , logs : Ok (Default :: default ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , outcome : Err ("no value supplied for outcome" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , } } } impl TestResult { pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn duration_ms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < u64 > > , T :: Error : :: std :: fmt :: Display , { self . duration_ms = value . try_into () . map_err (| e | format ! ("error converting supplied value for duration_ms: {}" , e)) ; self } pub fn environment_ref < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . environment_ref = value . try_into () . map_err (| e | format ! ("error converting supplied value for environment_ref: {}" , e)) ; self } pub fn error_message < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . error_message = value . try_into () . map_err (| e | format ! ("error converting supplied value for error_message: {}" , e)) ; self } pub fn executed_at < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > > , T :: Error : :: std :: fmt :: Display , { self . executed_at = value . try_into () . map_err (| e | format ! ("error converting supplied value for executed_at: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TestResultKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn logs < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . logs = value . try_into () . map_err (| e | format ! ("error converting supplied value for logs: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn outcome < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: TestResultOutcome > , T :: Error : :: std :: fmt :: Display , { self . outcome = value . try_into () . map_err (| e | format ! ("error converting supplied value for outcome: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < TestResult > for super :: TestResult { type Error = super :: error :: ConversionError ; fn try_from (value : TestResult) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { description : value . description ? , duration_ms : value . duration_ms ? , environment_ref : value . environment_ref ? , error_message : value . error_message ? , executed_at : value . executed_at ? , id : value . id ? , kind : value . kind ? , logs : value . logs ? , metadata : value . metadata ? , name : value . name ? , outcome : value . outcome ? , synonyms : value . synonyms ? , tags : value . tags ? , }) } } impl :: std :: convert :: From < super :: TestResult > for TestResult { fn from (value : super :: TestResult) -> Self { Self { description : Ok (value . description) , duration_ms : Ok (value . duration_ms) , environment_ref : Ok (value . environment_ref) , error_message : Ok (value . error_message) , executed_at : Ok (value . executed_at) , id : Ok (value . id) , kind : Ok (value . kind) , logs : Ok (value . logs) , metadata : Ok (value . metadata) , name : Ok (value . name) , outcome : Ok (value . outcome) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , } } } # [derive (Clone , Debug)] pub struct Tool { category : :: std :: result :: Result < super :: ToolCategory , :: std :: string :: String > , command_name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , description : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , installation_guide : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , kind : :: std :: result :: Result < super :: ToolKind , :: std :: string :: String > , metadata : :: std :: result :: Result < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , synonyms : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , tags : :: std :: result :: Result < :: std :: vec :: Vec < :: std :: string :: String > , :: std :: string :: String > , version_requirement : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , } impl :: std :: default :: Default for Tool { fn default () -> Self { Self { category : Err ("no value supplied for category" . to_string ()) , command_name : Err ("no value supplied for command_name" . to_string ()) , description : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , installation_guide : Ok (Default :: default ()) , kind : Err ("no value supplied for kind" . to_string ()) , metadata : Ok (Default :: default ()) , name : Err ("no value supplied for name" . to_string ()) , synonyms : Ok (Default :: default ()) , tags : Ok (Default :: default ()) , version_requirement : Ok (Default :: default ()) , } } } impl Tool { pub fn category < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ToolCategory > , T :: Error : :: std :: fmt :: Display , { self . category = value . try_into () . map_err (| e | format ! ("error converting supplied value for category: {}" , e)) ; self } pub fn command_name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . command_name = value . try_into () . map_err (| e | format ! ("error converting supplied value for command_name: {}" , e)) ; self } pub fn description < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . description = value . try_into () . map_err (| e | format ! ("error converting supplied value for description: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn installation_guide < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . installation_guide = value . try_into () . map_err (| e | format ! ("error converting supplied value for installation_guide: {}" , e)) ; self } pub fn kind < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ToolKind > , T :: Error : :: std :: fmt :: Display , { self . kind = value . try_into () . map_err (| e | format ! ("error converting supplied value for kind: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: serde_json :: Map < :: std :: string :: String , :: serde_json :: Value > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn synonyms < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . synonyms = value . try_into () . map_err (| e | format ! ("error converting supplied value for synonyms: {}" , e)) ; self } pub fn tags < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: vec :: Vec < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . tags = value . try_into () . map_err (| e | format ! ("error converting supplied value for tags: {}" , e)) ; self } pub fn version_requirement < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . version_requirement = value . try_into () . map_err (| e | format ! ("error converting supplied value for version_requirement: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Tool > for super :: Tool { type Error = super :: error :: ConversionError ; fn try_from (value : Tool) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { category : value . category ? , command_name : value . command_name ? , description : value . description ? , id : value . id ? , installation_guide : value . installation_guide ? , kind : value . kind ? , metadata : value . metadata ? , name : value . name ? , synonyms : value . synonyms ? , tags : value . tags ? , version_requirement : value . version_requirement ? , }) } } impl :: std :: convert :: From < super :: Tool > for Tool { fn from (value : super :: Tool) -> Self { Self { category : Ok (value . category) , command_name : Ok (value . command_name) , description : Ok (value . description) , id : Ok (value . id) , installation_guide : Ok (value . installation_guide) , kind : Ok (value . kind) , metadata : Ok (value . metadata) , name : Ok (value . name) , synonyms : Ok (value . synonyms) , tags : Ok (value . tags) , version_requirement : Ok (value . version_requirement) , } } } } # [doc = r" Generation of default values for serde."] pub mod defaults { pub (super) fn feature_status () -> super :: FeatureStatus { super :: FeatureStatus :: Proposed } pub (super) fn standard_compliance_level () -> super :: StandardComplianceLevel { super :: StandardComplianceLevel :: Mandatory } }
  |

error: could not compile `dass-engine` (lib) due to 3 previous errors
